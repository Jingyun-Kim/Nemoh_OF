!--------------------------------------------------------------------------------------
!
!   NEMOH2 - second order (QTF) - November 2014
!   Contributors list:
!    - Fabien Robaux (EDF/INNOSEA)
!    - G.DELHOMMEAU, THESE DE CHEN XIAO-BO(1988)    
!    - Adrien Combourieu, INNOSEA (adrien.combourieu@innosea.fr)
!--------------------------------------------------------------------------------------


PROGRAM HASFSASYMP

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!   PROGRAMME DE CALCUL DE LA PARTIE ASYMPTOTIQUE DES   !!!!!!!!!!
    !!!!!!!!!   EFFORTS DE SURFACE LIBRE. METHODE UTILISEE          !!!!!!!!!!
    !!!!!!!!!   DECRITE DANS LE RAPPORT DE STAGE DE FABIEN          !!!!!!!!!!
    !!!!!!!!!   ROBAUX POUR EDF/ INNOSEA                            !!!!!!!!!!
    !!!!!!!!!   ON INTEGRE ENTRE RAYINT ET L'INFINI ALD PSI DS      !!!!!!!!!!
    !!!!!!!!!   OU LES TERMES SONT APPROXIMES ASYMPTOTIQUEMENT      !!!!!!!!!!
    !!!!!!!!!   (>1/SQRT(R))                                        !!!!!!!!!!
    !!!!!!!!! PROGRAM FOR CALCULATING THE ASYMPTOTIC PART OF !!!!!!!!!!
    !!!!!!!!! FREE SURFACE EFFORTS. METHOD USED !!!!!!!!!!
    !!!!!!!!! DESCRIBED IN FABIEN'S INTERNSHIP REPORT !!!!!!!!!!
    !!!!!!!!! ROBAUX FOR EDF / INNOSEA !!!!!!!!!!
    !!!!!!!!! WE INTEGRATE BETWEEN RAYINT AND THE INFINITE ALD PSI DS !!!!!!!!!!
    !!!!!!!!! OR THE TERMS ARE ASYMPTOTICALLY APPROXIMATE !!!!!!!!!!
    !!!!!!!!! (> 1 / SQRT (R)) !!!!!!!!!!
    !!!!!!!!!                                                       !!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    USE PARA
    IMPLICIT NONE
    REAL AD
    COMMON BESSEL,XPLOT
    REAL,DIMENSION(0:NN,NPASZ) ::BESSEL
    REAL,DIMENSION(NPASZ) ::XPLOT
    INTEGER N
!    REAL ALPH!,KR!,YBESS
!    COMPLEX C1(NPASZ),C2(NPASZ)
    INTEGER NSYM,NFAC,NFFL,NDEB,NFIN
!NSYM: NOMBRE DE SYMETRIE (0 SI AUCUNE, 1 SI UNE (-Y,Y))
!NFAC: NOMBRE DE FACE DU CORP
!NFFL: NOMBRE DE SEGMENT INTERSECTION CORPS/SURFACE LIBRE
!? ?
    REAL RHO,XCDG,YCDG,ZCDG,TPER,BETA!MASSE VOL, COORDONEE DU CDG,?, ANGLE INCIDENCE
    COMMON NSYM,NFAC,NFFL,RHO,XCDG,YCDG,ZCDG,TPER,BETA,NDEB,NFIN
        INTEGER IND(2*NFA)
        REAL FSP(NFA),FSM(NFA)
        COMMON FSP,FSM
        REAL XSL(NFASL),YSL(NFASL)
        INTEGER M1SLF(NFASL),M2SLF(NFASL),M3SLF(NFASL),M4SLF(NFASL)
        INTEGER M1SLC(NFASL),M2SLC(NFASL)
        REAL,DIMENSION(6,6,LN):: AIN,ASH
        REAL,DIMENSION(6*LN,6*LN):: AMOR,RAID
        REAL,DIMENSION(2,NFA):: DNSRADR,DNSRADM  !DENSITE DE SOURCE RADIE
        REAL,DIMENSION(2,NFA):: DNSPERR,DNSPERM  !DENSITE DE SOURCE PERTURBE
       ! COMPLEX,DIMENSION(2,2,NFA):: DNSRADC !DENSITE DE SOURCE RADIE(PULSATION,?,FACETTE) COMPLXE
       ! COMPLEX,DIMENSION(2,2,NFA):: DNSPERC !DENSITE DE SOURCE PERTURBE(PULSATION,?,FACETTE) COMPLXE
        REAL CN(NFA2,6),NT(501),CNSLC(3,NFASL)
        INTEGER LK(5)
        REAL XR(328),XZ(46),APD1X(328,46),APD1Z(328,46),APD2X(328,46),APD2Z(328,46)
        COMMON/FIC/XR,XZ,APD1X,APD1Z,APD2X,APD2Z
        ! COMPLEX,DIMENSION(328,46)::APDXC,APDZC
        LOGICAL :: FICHEY!,ISIN
!        REAL :: LONG2
        REAL BP
        COMMON/BP1/BP
        CHARACTER(10) :: IDEN, ID
        CHARACTER(16) :: NOMF4!,NOMF2,NOMF1!,NOMF3!,NOMF5!,NOMF6
        CHARACTER(16) :: NOMB1,NOMB2,NOMB3,NOMB4,NOMB5
        CHARACTER(16) :: NOMH0,NOMH1,NOMH2,NOMH3,NOMH4,NOMH5
        CHARACTER(16) :: NOMGRUN, NOMBESS
	CHARACTER*800 STRFMT
        REAL X(NPT),Y(NPT),Z(NPT)
        INTEGER,DIMENSION(NFA)::M1,M2,M3,M4,P,Q,R
        COMMON X,Y,Z,M1,M2&
        &,M3,M4,P,Q,R
        REAL XM(2*NFA),YM(2*NFA),ZM(2*NFA),AIRE(NFA)
        COMMON/MAIL/ XM,YM,ZM,AIRE
        REAL TDIS(NFA)&
        &,AIND(NI),DIST(NFA)
        INTEGER IPOS(LN),IMXC(LN),KK(5), lID
        COMMON TDIS&
        &,IPOS,IMXC,KK,AIND,DIST
	REAL XMSLF(NFASL),YMSLF(NFASL),AIRESLF(NFASL)
        REAL XMSLC(NFASL),YMSLC(NFASL),AIRESLC(NFASL)
        REAL XMSLL(NFASL),YMSLL(NFASL),AIRESLL(NFASL)
        COMMON/DON2/ XMSLF,YMSLF,AIRESLF,XMSLC,YMSLC,AIRESLC,XMSLL,YMSLL,AIRESLL
        REAL VSXP1(NFA),VSYP1(NFA),VSZP1(NFA)&
     &   ,VSXM1(NFA),VSYM1(NFA),VSZM1(NFA)&
     &   ,VSXP2(NFA),VSYP2(NFA),VSZP2(NFA)&
      &  ,VSXM2(NFA),VSYM2(NFA),VSZM2(NFA)&
     &   ,SP1(NFA),SM1(NFA),SP2(NFA),SM2(NFA)
      COMMON/SOU/VSXP1,VSYP1,VSZP1&
     &   ,VSXM1,VSYM1,VSZM1&
     &   ,VSXP2,VSYP2,VSZP2&
      &  ,VSXM2,VSYM2,VSZM2&
     &   ,SP1,SM1,SP2,SM2&
      &  ,NOMF4
        REAL POT1,POT2,VXB1,VXB2,VYB1,VYB2,VZB1,VZB2
        COMMON/OUTVSBK/POT1,POT2,VXB1,VXB2,VYB1,VYB2,VZB1,VZB2
	COMPLEX, DIMENSION(:,:,:), ALLOCATABLE ::POTINCSLF,POTTOTSLF,POTPERSLF,POTINCSLC,POTTOTSLC,POTPERSLC,POTINCSLL,POTTOTSLL,POTPERSLL
        COMPLEX, DIMENSION(:,:,:,:), ALLOCATABLE ::POTRADSLF,POTRADSLC,POTRADSLL
        COMPLEX, DIMENSION(:,:,:,:), ALLOCATABLE ::VINCSLF,VTOTSLF,VPERSLF,VINCSLC,VTOTSLC,VPERSLC,VINCSLL,VTOTSLL,VPERSLL
        COMPLEX, DIMENSION(:,:,:,:,:), ALLOCATABLE ::VRADSLF,VRADSLC,VRADSLL
        COMMON/VSB/IDEN
        REAL XEFF,YEFF,ZEFF,GM,H,PI4,DPI,QPI
        INTEGER NSYMY,NJJ,NP,IMX,IXX,NEXP,NC,NCO
        COMMON/CST/NC,NCO,NSYMY,NJJ,NP,IMX,IXX,XEFF,YEFF,ZEFF,GM,&
      &  H,PI4,DPI,QPI,NEXP
        COMPLEX ZSB(NFA),ZSS(NFA)
        CHARACTER(1)FMTV
        CHARACTER*50 FMT1,FMT2!,CHARAC
!        INTEGER :: FICH!,FICH2
!        COMPLEX,DIMENSION(1:6,1:6,1:NFA,1:NFA)::CONTRIB
!        COMPLEX :: ALD
        COMPLEX,DIMENSION(:,:,:),ALLOCATABLE::CSL,SSL
        COMPLEX CL,SL,KOCH,KOCHIN!,BESS2,BESS1
        REAL LONG,K1,K2,K3,K4!,DZ,F3,INTMAXR,INTMINR
        REAL RAY,PASR
        COMPLEX INTBESS,MK!,DR!,FX,INTBESSI
        COMPLEX CONST,CONSTR,TEMP,TEMPB,TEMP2,TEMP2B,TEMP2PREB,TEMP2PRE,TEMP3,TEMP3B,POTRAD(6),FTHETARADM(6),FTHETARADP(6)
	COMPLEX FTHETAPER,POTINC,POTPER,POTINC1,POTINC2,POTPER1,POTPER2,FTHETAPER1,FTHETAPER2,INTMdz!,PINCP,PINCM!,TEMP
	COMPLEX POTINC1_Z,POTINC1_Y,POTINC1_X,POTINC2_Z,POTINC2_Y,POTINC2_X,POTPER1_Z,POTPER1_Y,POTPER1_X,POTPER2_Z,POTPER2_Y,POTPER2_X
	COMPLEX POTRADM(6),POTRADP(6),POTRADM_Z(6),POTRADP_Z(6),POTRADM_Y(6),POTRADP_Y(6),POTRADM_X(6),POTRADP_X(6)
	COMPLEX POTTOT1,POTTOT2,POTTOT1_Z,POTTOT2_Z,POTTOT1_Y,POTTOT2_Y,POTTOT1_X,POTTOT2_X
        COMPLEX,DIMENSION(:),ALLOCATABLE:: KPER,KRAD,VERIF,VERIFPR,VERIF1,VERIF2,VERIF1PR,VERIF2PR!,QTFASYMP
        COMPLEX,DIMENSION(:,:,:,:),ALLOCATABLE::EFFVERIF,EFFSLM,EFFSLP
	
!        COMPLEX,DIMENSION(:,:),ALLOCATABLE::AL!,MOY
        REAL,DIMENSION(:),ALLOCATABLE::TABW,TABK
        !COMPLEX PI1,PI2,PP1,PP2,PRAD,FR1,FR2,FR3,ALTOT(6)!,VALPRMOY(6,50)
        !REAL RMOYMAX(6),IMOYMAX(6)
        !REAL RMOYMIN(6),IMOYMIN(6)
        !REAL RMOYMOY(6),IMOYMOY(6)
        REAL MINR,RCEREXT,RAYINT,RAY0
!        LOGICAL FIN
        INTEGER FAITW(4,40,40)
!        INTEGER ISLM
        COMPLEX UJ,KJ,SOMMEJ,DIFFJ,XI,XIPR,LAMBDAN,SOMMEJPR,DIFFJPR,UJPR,KJPR,&
        &INTDIFF12,INTEGR1,INTEGR2,INTEGTOT5,PHII1,PHIP1,PSI,PHII2,PHIP2,DR1,DR2,DR3,DR4,DR1B,DR2B!,GAMMAN
        REAL AK0,AM0,AMZ,BETA1,CB,DEC,DECI,ERRMAX,DZ
        INTEGER I,IDOF,I1,IFACSL,IJ,IJK,IJKI,IJKJ,IJKK,IK,ILIN,ILLOCOK,IMIN
        INTEGER ILLOC_STAT5,ILLOC_STAT4,ILLOC_STAT3,ILLOC_STAT2,ILLOC_STAT,ILLOC_STAT6,&
        &ILLOC_STAT7,ILLOC_STAT8,ILLOC_STAT9,I2
        INTEGER IOUI,IR,JZ,IREC,ITEST,J,JJ,JQ,K,KBES,KNC,NCONT,NOMBPO,NLIGNE
        INTEGER NFACSL,NIJ,NIN,NJ,NL,NM,NN2,NPASR,NPRINTW1,NPRINTW2,NBPASR
        INTEGER NR1,NR3,NR5,NR8,NR9,NR10
        INTEGER NTHETA,NTHETAMAX,NTOT,NW1,NW2,NW3,NW4,NPRINTW3,NPRINTW4!,IXMX
        REAL OMEG,RMAX,RAY2,RMIN,SB,T,TEST,THETA,TR,VA,W1,W2,WM,WP!,ZER
        REAL WR,WR1,XL
        INTEGER IL,IPASR,NR!,LRAY
        REAL X0,F3
        REAL F1,EPS,APBES!,F2
	INTEGER,DIMENSION(:),ALLOCATABLE:: IRCER
        REAL,DIMENSION(:),ALLOCATABLE:: RAYONS,RCER
        COMPLEX,DIMENSION(:),ALLOCATABLE::INTEGTH,INTEGTHB,INTEGTHR,INTEGTHR2
        COMPLEX PDSOMME,PDSOMMEB,INTEG,INTEGB,INTEG2,INTEG3,INTEG3B,INTEG4,INTEG4B,&
        & INTEGTOT,INTEGTOT2,INTEGTOT3,INTEGTOTR3,INTEGTOTR3B,INTEGTOTB,INTEGTOT2B,INTEGTOT3B,&
	& INTEGR3,INTEGR4,INTEGTOTR,INTEGTOTBR,INTEGTOTR2,INTEGTOTBR2,&
!~ 	& SUM1M(6),SUM2M(6),SUM3M(6),SUM4M(6),SUM1P(6),SUM2P(6),SUM3P(6),SUM4P(6)
	& SUM1M,SUM2M,SUM3M,SUM4M,SUM1P,SUM2P,SUM3P,SUM4P
        REAL PASTHETA
        COMPLEX CONSTANTE,CST_R,CONSTANTEB,CST_RPR,KAPP2Mdz,KAPP2Pdz,KAPP1Mdz,KAPP1Pdz!,KAPPA1,KAPPA2
        COMPLEX V(-1:NN,900)
        COMPLEX U(0:NN)
        COMPLEX VB(0:NN,900)
        COMPLEX UB(0:NN)
!~         COMPLEX CST1M,CST2M,CST3M,CST4M,CST1P,CST2P,CST3P,CST4P !CF COMMENTAIRES LES ACCOMPAGNANTS.
        COMPLEX,DIMENSION(:,:),ALLOCATABLE::CST1M,CST2M,CST1P,CST2P,KAPPA1M0,KAPPA2M0,KAPPA1P0,KAPPA2P0 !CF COMMENTAIRES LES ACCOMPAGNANTS.
        COMPLEX KAPPA1Mdz,KAPPA2Mdz,KAPPA1Mdzz,KAPPA2Mdzz !CF COMMENTAIRES LES ACCOMPAGNANTS.
        COMPLEX KAPPA1Pdz,KAPPA2Pdz,KAPPA1Pdzz,KAPPA2Pdzz !CF COMMENTAIRES LES ACCOMPAGNANTS.
!~         COMPLEX ISLM(6),ISLM1(6),ISLM2(6),ISLM3(6),ISLP(6),VJ1,VJ2 !! IINT A_LD PSI(6) DS (NOTATIONS DE CHEN OU RAPPORT DE STAGE)
        COMPLEX ISLM_0,ISLM_DZ,ISLM_DZZ,ISLM1,ISLM2,ISLM3,VJ1,VJ2 !! IINT A_LD PSI(6) DS (NOTATIONS DE CHEN OU RAPPORT DE STAGE)
        COMPLEX ISLP_0,ISLP_DZ,ISLP_DZZ !! IINT A_LD PSI(6) DS (NOTATIONS DE CHEN OU RAPPORT DE STAGE)
        REAL TH1,TH2,NAN,R1,R2,DRAY,XPOT,YPOT
	INTEGER :: LQTFP,NHASKIND,ICER,NRCER,INDFACLIM,Louthasfs,ISYM,N1,DOFSYM,IJPRINT
!~ 	COMPLEX,DIMENSION(0:NN) :: INTDIFF1M,INTDIFF2M,INTDIFF3M,INTDIFF4M
!~ 	COMPLEX,DIMENSION(0:NN) :: INTDIFF1P,INTDIFF2P,INTDIFF3P,INTDIFF4P
	COMPLEX,DIMENSION(:,:,:,:),ALLOCATABLE:: INTDIFF1M,INTDIFF2M,INTDIFF1P,INTDIFF2P,U1JM,U2JM,U1JP,U2JP
	COMPLEX,DIMENSION(:,:,:),ALLOCATABLE:: LAMBDAN1M,LAMBDAN2M,LAMBDAN1P,LAMBDAN2P
	NAN=0.
	NAN=NAN/NAN
  

    OPEN(7,FILE="ID.dat")
    READ(7,*) lID
    READ(7,*) ID
    CLOSE(7)
    



    !!!!!!!!!!!!!                                           !!!!!!!!!!!!!!!!!
    !!!!!     OUVERTURE ET ENREGISTREMENT DE GEOMETRIE COMPLETE        !!!!!!
    !!!!!!!!!!!!!                                           !!!!!!!!!!!!!!!!!
        NOMF4=ID(1:lID)//'/QTF/FA.RES'
        INQUIRE(FILE=NOMF4,EXIST=FICHEY)
        OPEN(UNIT=12,FILE=NOMF4,ACCESS='DIRECT',STATUS='UNKNOWN',RECL=4*4*NFA)
        READ(12,REC=1)NC,NCO,NSYM,NP,NFAC,IXX,XEFF,YEFF,ZEFF,&
        & (IMXC(I),I=1,NCO),(IPOS(I),I=1,NC),BP,T,IMIN,H,AMZ,ILIN,&
        & RHO,VA,BETA,WR,AM0,NIN,(AIND(I),I=1,NIN)
        READ(12,REC=2)(X(I),I=1,NP)
        READ(12,REC=3)(Y(I),I=1,NP)
        READ(12,REC=4)(Z(I),I=1,NP)
        READ(12,REC=5)(M1(I),I=1,NFAC),(M2(I),I=1,NFAC),&
        &(M3(I),I=1,NFAC),(M4(I),I=1,NFAC)


	IMX = NFAC

        READ(12,REC=6)(P(I),I=1,NFAC),(Q(I),I=1,NFAC),(R(I),I=1,NFAC)
        READ(12,REC=7)(XM(I),I=1,NFAC),(YM(I),I=1,NFAC),(ZM(I),I=1,NFAC)
        READ(12,REC=8)(AIRE(I),I=1,NFAC),(TDIS(I),I=1,NFAC),&
        &(DIST(I),I=1,NFAC)
        I1=NFAC+1
        READ(12,REC=9)(XM(I),I=I1,IXX),(YM(I),I=I1,IXX),(ZM(I),I=I1,IXX),&
        &(IND(I),I=1,IXX-NFAC)

        JQ=6*NC
        READ(12,REC=10)(((AIN(I,J,K),I=1,6),J=1,6),&
        &((ASH(I,J,K),I=1,6),J=1,6),K=1,NC),((RAID(I,J),I=1,JQ),J=1,JQ),&
        &((AMOR(I,J),I=1,JQ),J=1,JQ)
        CLOSE(12)

        NFFL=IXX-NFAC!NOMBRE DE LIGNE DE LA SURFACE DE FLOTAISON
        WRITE(*,*)'NFAC=',NFAC,'NFFL=',NFFL,'IXX=',IXX
        NL=NFAC+NFFL!NL=IXX
        XCDG=XEFF
        YCDG=YEFF
        ZCDG=ZEFF
        NDEB=0
        NFIN=NFAC+NFFL


        DO 399 I=1,NFFL
            LK(1)=M1(IND(I))
            LK(2)=M2(IND(I))
            LK(3)=M3(IND(I))
            LK(4)=M4(IND(I))

            LK(5)=LK(1)
            P(NFAC+I)=P(IND(I))
            Q(NFAC+I)=Q(IND(I))
            R(NFAC+I)=0
        ! LES QUANTITES N'ONT PAS ETE CALCULEES EN Z=0 A LA FLOTTAISON
        ! CEPENDANT ECRIRE ZSL=0 PERMET D'ETRE EXACT DANS LA GEOMETRIE (LES CN)
            ZM(IMX+I)=0.
            DO 399 J=1,4
                TEST=(X(LK(J))-X(LK(J+1)))**2+(Y(LK(J))-Y(LK(J+1)))**2
                IF(ABS(Z(LK(J)))+ABS(Z(LK(J+1))) < 1.E-05 .AND. TEST > 1.E-5)THEN
                    AIRE(NFAC+I)=SQRT(TEST)
                ! !   AIRE(I),I>NFAC, EST LA LONGUEUR DES COTES A LA FLOTTAISON
                ENDIF
                CONTINUE
        399 END DO
    !
        DO 101 I=1,NL
            CN(I,1)=P(I)
            CN(I,2)=Q(I)
            CN(I,3)=R(I)
            CN(I,4)=(YM(I)-YEFF)*CN(I,3)-(ZM(I)-ZEFF)*CN(I,2)
            CN(I,5)=(ZM(I)-ZEFF)*CN(I,1)-(XM(I)-XEFF)*CN(I,3)
            CN(I,6)=(XM(I)-XEFF)*CN(I,2)-(YM(I)-YEFF)*CN(I,1)
            CONTINUE
        101 END DO
    !
        BETA=BETA/RADD
        CB=COS(BETA)
        SB=SIN(BETA)
        NJ=NSYM+1
	
	DOFSYM=1
	IF (NJ==2 .AND. BETA==0) DOFSYM=2
	WRITE(*,*) 'DOF = ',(I,I=1,6,DOFSYM)
    
    !
    ! ---- FICHIERS DES QUANTITES DU PREMIER ORDRE  -----
        NOMB1=ID(1:lID)//'/QTF/B1.RES'
        NOMB2=ID(1:lID)//'/QTF/B2.RES'
        NOMB3=ID(1:lID)//'/QTF/B3.RES'
        NOMB4=ID(1:lID)//'/QTF/B4.RES'
    ! ---- FICHIERS PROBLEMES ADDITIONNELS DE RADIATION  -----
        NOMH1=ID(1:lID)//'/QTF/H1.RES'
        NOMH2=ID(1:lID)//'/QTF/H2.RES'
        NOMH3=ID(1:lID)//'/QTF/H3.RES'
        NOMH4=ID(1:lID)//'/QTF/H4.RES'
        NR1=3+24*NC+72*NC**2+NFFL*2*NJ
        NR3=NL*2*NJ

        OPEN(21,FILE=NOMB1,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR1)
        OPEN(22,FILE=NOMB2,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR3)
        OPEN(23,FILE=NOMB3,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR3)
        OPEN(24,FILE=NOMB4,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR3)
    !
        NOMB5=ID(1:lID)//'/QTF/AH.RES'
        OPEN(UNIT=40,FILE=NOMB5,STATUS='UNKNOWN')

        XL=1
        AD=RHO*G*XL
    ! SOMMATION SUR 1 SEUL CORPS
        KNC=1
    !
    ! PROCEDURE VALABLE SI W(NT(I)-NT(I-1))=W(I)-W(I-1)
        READ(LL,*) N
!~         WRITE(LE,*)' ENTRER LES NUMEROS D''ENREGISTREMENTS DANS L''ORDRE'
!~         WRITE(LE,*)' DES PULSATIONS CROISSANTES (PERIODES DECROISSANTES)'
	READ(LL,*) (NT(I),I=1,N)
        READ(LL,*) LQTFP
        READ(LL,*) 
        READ(LL,*) 
        READ(LL,*) 
        READ(LL,*) Louthasfs,NPRINTW1,NPRINTW2,IJPRINT
	READ(LL,*) NRCER
	ALLOCATE(RCER(NRCER))
	ALLOCATE(IRCER(NRCER))
	READ(LL,*) (IRCER(I),I=1,NRCER)

	
!!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
!~        IF (LHASK>1 .AND. LQTFP==1) THEN                               
! SI LES QTF+ SONT CALCULES, IL FAUT REDUIRE LE NOMBRE DE PULSATION
!~              NHASKIND=N/2
!~        ELSE
!~              NHASKIND=N
!~        ENDIF
!~        PRINT*, 'N =',N,'NHASKIND =',NHASKIND
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
        ITEST=1
        IF(ITEST == 1)THEN
        ! CALCUL AUTOMATIQUE
            NN2=0
        ELSE
        ! CAS TEST
            PRINT*,'NOMBRE DE PERIODES COMBINEES ?'
            READ(*,*)NM
!~             NN2=NHASKIND-NM
            NN2=N-NM
        ENDIF
    !!!!!!!!!!!!!                                           !!!!!!!!!!!!!!!!!
    !!!!!               IMPORTATION DES FONCTIONS DE GREEN             !!!!!!
    !!!!!!!!!!!!!                                           !!!!!!!!!!!!!!!!!
  !       NOMGRUN = ID(1:lID)//'/QTF/GRUN.QAT'
  !       OPEN(UNIT=44,FILE=NOMGRUN,FORM='UNFORMATTED',STATUS='OLD')
  !       READ(44)IR,JZ,(XR(I),I=1,IR),(XZ(J),J=1,JZ)
  !       DO 1515 J=1,JZ
  !           READ(44)(APD1X(I,J),I=1,IR),(APD1Z(I,J),I=1,IR),&
  !           &(APD2X(I,J),I=1,IR),(APD2Z(I,J),I=1,IR)
  !           CONTINUE
  !       1515 END DO
  !       CLOSE(UNIT=44)
  !       APDXC=CMPLX(APD1X,APD2X)
  !       APDZC=CMPLX(APD1Z,APD2Z)
    !!!!!!!!!!!!!! FIN D'IMPORTATION DES FONCTIONS DE GREEN    !!!!!!!!!!!!!!
        NOMH0=ID(1:lID)//'/QTF/H0.RES'
        NR8=(2*IMX*NJ+3)*2
        OPEN(30,FILE=NOMH0,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR8)
        NR5=(NL*2*NJ+3)
        NR3=IXX*2*NJ
        NOMH5=ID(1:lID)//'/QTF/H5.RES'
	
	OPEN(25,FILE=NOMH5,STATUS='UNKNOWN',ACCESS='DIRECT',RECL=4*NR8)


    !!!!IMPORTATION DES DENSITES DE SOURCES!        NOMH0='sing.wat'

    NR9=2*2*4*NFASL*2
    OPEN(11,FILE='SF_L12.RES',STATUS='OLD',ACCESS='DIRECT',RECL=NR9)
        READ(11,REC=1)NSYMY,NFACSL,NCONT,NOMBPO,NLIGNE,RCEREXT,NPASR
        WRITE(*,*) "NSYMY =",NSYMY,"NFACSL =",NFACSL,"NCONT =",NCONT,"NOMBPO =",NOMBPO,"NLIGNE =",NLIGNE,"RCEREXT =",RCEREXT,"NPASR =",NPASR
        READ(11,REC=2)(XSL(I),YSL(I),I=1,NOMBPO)
        READ(11,REC=3)(XMSLF(I),YMSLF(I),I=1,NFACSL),(XMSLC(I),YMSLC(I),I=1,NCONT),(XMSLL(I),YMSLL(I),I=1,NLIGNE)
        READ(11,REC=4)(AIRESLF(I),I=1,NFACSL),(AIRESLC(I),I=1,NCONT)
        READ(11,REC=5)(CNSLC(1,I),CNSLC(2,I),I=1,NCONT)
        READ(11,REC=6)(M1SLF(I),M2SLF(I),I=1,NFACSL),(M1SLC(I),M2SLC(I),I=1,NCONT)
        READ(11,REC=7)(M3SLF(I),M4SLF(I),I=1,NFACSL)
    CLOSE(11)
	NTHETA=NFACSL/NPASR
	DO ICER=1,NRCER
	    	INDFACLIM=NTHETA*IRCER(ICER)
		R1=SQRT(XMSLF(INDFACLIM)**2+YMSLF(INDFACLIM)**2)
		R2=SQRT(XMSLF(INDFACLIM+1)**2+YMSLF(INDFACLIM+1)**2)
		RCER(ICER)=(R1+R2)/2/COS(PI/NJ/NTHETA)
	END DO
	
	NTOT=NFACSL+NCONT+NLIGNE
        NPASR=900

!!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
!~         ALLOCATE(VINCSLF(2,3,NHASKIND,NFACSL),STAT = ILLOC_STAT6)!! SUR LES FACETTES
!~         ALLOCATE(VPERSLF(2,3,NHASKIND,NFACSL),STAT = ILLOC_STAT6)
!~         ALLOCATE(VTOTSLF(2,3,NHASKIND,NFACSL),STAT = ILLOC_STAT8)
!~         ALLOCATE(POTINCSLF(2,NHASKIND,NFACSL),STAT = ILLOC_STAT5)
!~         ALLOCATE(POTTOTSLF(2,NHASKIND,NFACSL),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTPERSLF(2,NHASKIND,NFACSL),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTRADSLF(2,6,N,NFACSL),STAT = ILLOC_STAT3)
!~         ALLOCATE(VRADSLF(2,3,6,N,NFACSL),STAT = ILLOC_STAT4)
!~ 	
!~         ALLOCATE(VINCSLC(2,3,NHASKIND,NCONT),STAT = ILLOC_STAT6)!! SUR LES CONTOURS
!~         ALLOCATE(VPERSLC(2,3,NHASKIND,NCONT),STAT = ILLOC_STAT6)
!~         ALLOCATE(VTOTSLC(2,3,NHASKIND,NCONT),STAT = ILLOC_STAT8)
!~         ALLOCATE(POTINCSLC(2,NHASKIND,NCONT),STAT = ILLOC_STAT5)
!~         ALLOCATE(POTTOTSLC(2,NHASKIND,NCONT),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTPERSLC(2,NHASKIND,NCONT),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTRADSLC(2,6,N,NCONT),STAT = ILLOC_STAT3)
!~         ALLOCATE(VRADSLC(2,3,6,N,NCONT),STAT = ILLOC_STAT4)
!~ 	
!~         ALLOCATE(VINCSLL(2,3,NHASKIND,NLIGNE),STAT = ILLOC_STAT6)!! SUR LA LIGNE
!~         ALLOCATE(VPERSLL(2,3,NHASKIND,NLIGNE),STAT = ILLOC_STAT6)
!~         ALLOCATE(VTOTSLL(2,3,NHASKIND,NLIGNE),STAT = ILLOC_STAT8)
!~         ALLOCATE(POTINCSLL(2,NHASKIND,NLIGNE),STAT = ILLOC_STAT5)
!~         ALLOCATE(POTTOTSLL(2,NHASKIND,NLIGNE),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTPERSLL(2,NHASKIND,NLIGNE),STAT = ILLOC_STAT7)
!~         ALLOCATE(POTRADSLL(2,6,N,NLIGNE),STAT = ILLOC_STAT3)
!~         ALLOCATE(VRADSLL(2,3,6,N,NLIGNE),STAT = ILLOC_STAT4)
!~ 	
!~         ALLOCATE(VERIF(NPASR))
!~         ALLOCATE(VERIF1(NPASR))
!~         ALLOCATE(VERIF2(NPASR))
!~         ALLOCATE(VERIF1PR(NPASR))
!~         ALLOCATE(VERIF2PR(NPASR))
!~         ALLOCATE(VERIFPR(NPASR))
!~         ALLOCATE(EFFVERIF(6,NHASKIND,NHASKIND,NPASR))
!~         ALLOCATE(RAYONS(1000))
!~         ALLOCATE(INTEGTH(1000))
!~         ALLOCATE(INTEGTHB(1000))
!~         ALLOCATE(INTEGTHR(1000))
!~         ALLOCATE(INTEGTHR2(1000))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!!
	ALLOCATE(VINCSLF(2,3,N,NFACSL),STAT = ILLOC_STAT6)!! SUR LES FACETTES
        ALLOCATE(VPERSLF(2,3,N,NFACSL),STAT = ILLOC_STAT6)
        ALLOCATE(VTOTSLF(2,3,N,NFACSL),STAT = ILLOC_STAT8)
        ALLOCATE(POTINCSLF(2,N,NFACSL),STAT = ILLOC_STAT5)
        ALLOCATE(POTTOTSLF(2,N,NFACSL),STAT = ILLOC_STAT7)
        ALLOCATE(POTPERSLF(2,N,NFACSL),STAT = ILLOC_STAT7)
        ALLOCATE(POTRADSLF(2,6,N,NFACSL),STAT = ILLOC_STAT3)
        ALLOCATE(VRADSLF(2,3,6,N,NFACSL),STAT = ILLOC_STAT4)
	
        ALLOCATE(VINCSLC(2,3,N,NCONT),STAT = ILLOC_STAT6)!! SUR LES CONTOURS
        ALLOCATE(VPERSLC(2,3,N,NCONT),STAT = ILLOC_STAT6)
        ALLOCATE(VTOTSLC(2,3,N,NCONT),STAT = ILLOC_STAT8)
        ALLOCATE(POTINCSLC(2,N,NCONT),STAT = ILLOC_STAT5)
        ALLOCATE(POTTOTSLC(2,N,NCONT),STAT = ILLOC_STAT7)
        ALLOCATE(POTPERSLC(2,N,NCONT),STAT = ILLOC_STAT7)
        ALLOCATE(POTRADSLC(2,6,N,NCONT),STAT = ILLOC_STAT3)
        ALLOCATE(VRADSLC(2,3,6,N,NCONT),STAT = ILLOC_STAT4)
	
        ALLOCATE(VINCSLL(2,3,N,NLIGNE),STAT = ILLOC_STAT6)!! SUR LA LIGNE
        ALLOCATE(VPERSLL(2,3,N,NLIGNE),STAT = ILLOC_STAT6)
        ALLOCATE(VTOTSLL(2,3,N,NLIGNE),STAT = ILLOC_STAT8)
        ALLOCATE(POTINCSLL(2,N,NLIGNE),STAT = ILLOC_STAT5)
        ALLOCATE(POTTOTSLL(2,N,NLIGNE),STAT = ILLOC_STAT7)
        ALLOCATE(POTPERSLL(2,N,NLIGNE),STAT = ILLOC_STAT7)
        ALLOCATE(POTRADSLL(2,6,N,NLIGNE),STAT = ILLOC_STAT3)
        ALLOCATE(VRADSLL(2,3,6,N,NLIGNE),STAT = ILLOC_STAT4)
		
        ALLOCATE(VERIF(NPASR))
        ALLOCATE(VERIF1(NPASR))
        ALLOCATE(VERIF2(NPASR))
        ALLOCATE(VERIF1PR(NPASR))
        ALLOCATE(VERIF2PR(NPASR))
        ALLOCATE(VERIFPR(NPASR))
        ALLOCATE(EFFVERIF(6,N,N,NPASR))
        ALLOCATE(RAYONS(1000))
        ALLOCATE(INTEGTH(1000))
        ALLOCATE(INTEGTHB(1000))
        ALLOCATE(INTEGTHR(1000))
        ALLOCATE(INTEGTHR2(1000))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        ILLOCOK=ILLOC_STAT+ILLOC_STAT2+ILLOC_STAT3+ILLOC_STAT4+ILLOC_STAT5+ILLOC_STAT6+ILLOC_STAT7+ILLOC_STAT8+ILLOC_STAT9
        IF (ILLOCOK/=0)THEN
            PRINT *,'ERROR'
            PRINT *,ILLOC_STAT,ILLOC_STAT2,ILLOC_STAT3,ILLOC_STAT4,ILLOC_STAT5,ILLOC_STAT6,ILLOC_STAT7,ILLOC_STAT8,ILLOC_STAT9
        ENDIF
        NTOT=NFACSL+NCONT+NLIGNE
		NR10=NTOT*2*2*4
        OPEN(12,FILE='POTENTIELS_SL.RES',ACCESS='DIRECT',RECL=2*NR10)
        DO 194 IJK=1,N
            IREC=(IJK-1)*36
!~ 	    IF (IJK .LE. NHASKIND) THEN					! version matrice carre pour les QTF+
	    IF (IJK .LE. N) THEN					! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs)
		READ(12,REC=IREC+1)(POTTOTSLF(1,IJK,IFACSL),IFACSL=1,NFACSL),(POTTOTSLC(1,IJK,IFACSL),IFACSL=1,NCONT),(POTTOTSLL(1,IJK,IFACSL),IFACSL=1,NLIGNE),(POTTOTSLF(2,IJK,IFACSL),IFACSL=1,NFACSL),(POTTOTSLC(2,IJK,IFACSL),IFACSL=1,NCONT),(POTTOTSLL(2,IJK,IFACSL),IFACSL=1,NLIGNE)
		READ(12,REC=IREC+2)(POTINCSLF(1,IJK,IFACSL),IFACSL=1,NFACSL),(POTINCSLC(1,IJK,IFACSL),IFACSL=1,NCONT),(POTINCSLL(1,IJK,IFACSL),IFACSL=1,NLIGNE),(POTINCSLF(2,IJK,IFACSL),IFACSL=1,NFACSL),(POTINCSLC(2,IJK,IFACSL),IFACSL=1,NCONT),(POTINCSLL(2,IJK,IFACSL),IFACSL=1,NLIGNE)
		READ(12,REC=IREC+3)(POTPERSLF(1,IJK,IFACSL),IFACSL=1,NFACSL),(POTPERSLC(1,IJK,IFACSL),IFACSL=1,NCONT),(POTPERSLL(1,IJK,IFACSL),IFACSL=1,NLIGNE),(POTPERSLF(2,IJK,IFACSL),IFACSL=1,NFACSL),(POTPERSLC(2,IJK,IFACSL),IFACSL=1,NCONT),(POTPERSLL(2,IJK,IFACSL),IFACSL=1,NLIGNE)
	    ENDIF
		DO 196 IK=1,6,DOFSYM
		    READ(12,REC=IREC+3+IK)(POTRADSLF(1,IK,IJK,IFACSL),IFACSL=1,NFACSL),(POTRADSLC(1,IK,IJK,IFACSL),IFACSL=1,NCONT),(POTRADSLL(1,IK,IJK,IFACSL),IFACSL=1,NLIGNE),(POTRADSLF(2,IK,IJK,IFACSL),IFACSL=1,NFACSL),(POTRADSLC(2,IK,IJK,IFACSL),IFACSL=1,NCONT),(POTRADSLL(2,IK,IJK,IFACSL),IFACSL=1,NLIGNE)
 196  CONTINUE
            DO 192 IDOF=1,3
!~ 		IF (IJK .LE. NHASKIND) THEN				! version matrice carre pour les QTF+
		IF (IJK .LE. N) THEN					! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs)
		    READ(12,REC=IREC+10+9*(IDOF-1)) (VTOTSLF(1,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VTOTSLC(1,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VTOTSLL(1,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE),(VTOTSLF(2,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VTOTSLC(2,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VTOTSLL(2,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE)
		    READ(12,REC=IREC+11+9*(IDOF-1)) (VINCSLF(1,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VINCSLC(1,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VINCSLL(1,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE),(VINCSLF(2,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VINCSLC(2,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VINCSLL(2,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE)
		    READ(12,REC=IREC+12+9*(IDOF-1)) (VPERSLF(1,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VPERSLC(1,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VPERSLL(1,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE),(VPERSLF(2,IDOF,IJK,IFACSL),IFACSL=1,NFACSL),(VPERSLC(2,IDOF,IJK,IFACSL),IFACSL=1,NCONT),(VPERSLL(2,IDOF,IJK,IFACSL),IFACSL=1,NLIGNE)
		ENDIF
                DO 195 IK=1,6,DOFSYM
		    READ(12,REC=IREC+12+(IDOF-1)*9+IK) (VRADSLF(1,IDOF,IK,IJK,IFACSL),IFACSL=1,NFACSL),(VRADSLC(1,IDOF,IK,IJK,IFACSL),IFACSL=1,NCONT),(VRADSLL(1,IDOF,IK,IJK,IFACSL),IFACSL=1,NLIGNE),(VRADSLF(2,IDOF,IK,IJK,IFACSL),IFACSL=1,NFACSL),(VRADSLC(2,IDOF,IK,IJK,IFACSL),IFACSL=1,NCONT),(VRADSLL(2,IDOF,IK,IJK,IFACSL),IFACSL=1,NLIGNE)
195   CONTINUE
192   CONTINUE
194   CONTINUE
        CLOSE(12)




    NOMBESS = ID(1:lID)//'/QTF/BESS.QAT'
    OPEN(55,FILE=NOMBESS,ACCESS='DIRECT',RECL=8*NPASZ)

DO 10 KBES=0,NN
        READ(55,REC=KBES+1)(XPLOT(I),I=1,NPASZ),(BESSEL(KBES,I),I=1,NPASZ)
10  CONTINUE

!~ NPRINTW1=20 !NHASKIND
!~ NPRINTW2=19 !NHASKIND-1
!~ IJPRINT=3

PRINT*, 'NPRINTW1 =',NPRINTW1,'NPRINTW2 =',NPRINTW2,'DOF_PRINT =',IJPRINT

!!!!!!!!                                                !!!!!!!!!!!!!
!!!     CALCUL DES COEFFICIENTS DE LA SERIE DES POTENTIELS      !!!!!
!!!!!!!!                                                !!!!!!!!!!!!!
    ALLOCATE(CSL(7,0:NN,N))
    ALLOCATE(SSL(7,0:NN,N))
    DO 7798 IJK=1,N
        DO 9810 IJ=1,6,DOFSYM
            NIJ=(IJK-1)*6+IJ    !DE 1 A 6, DENSITE DE SOURCES SUR LES FACETTES IMPORTES
            READ(30,REC=NIJ)TR,BETA,AK0,&
                &((DNSRADR(JJ,J),J=1,IMX),JJ=1,NJ),&
                &((DNSRADM(JJ,J),J=1,IMX),JJ=1,NJ)

            IF(H.LT.1.E10)THEN
                AM0=X0(AK0*H)/H
            ELSE
                AM0=AK0
            ENDIF

            DO 9831 J=1,IMX
                ZSB(J)=CMPLX(DNSRADR(1,J),DNSRADM(1,J))!IMPORTATION DES DENSITES DE SOURCES DEPUIS LE FICHIER REMPLI PAR STOKKK
                ZSS(J)=CMPLX(DNSRADR(2,J),DNSRADM(2,J))
	9831  CONTINUE
        DO 9810 KBES=0,NN
            CSL(1+IJ,KBES,IJK)=CL(KBES,ZSB,ZSS,AM0)
            SSL(1+IJ,KBES,IJK)=SL(KBES,ZSB,ZSS,AM0)
            !PRINT *,'REMPLISAGE I',1+IJ,CSL(1+IJ,KBES,IJK),SSL(1+IJ,KBES,IJK)
	9810 CONTINUE

!~ 	IF (IJK .LE. NHASKIND) THEN					! version matrice carre pour les QTF+
	IF (IJK .LE. N) THEN						! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs)
		READ(25,REC=IJK)TR,BETA,AK0,&
		    &((DNSPERR(JJ,J),J=1,IMX),JJ=1,NJ),&
		    &((DNSPERM(JJ,J),J=1,IMX),JJ=1,NJ)
		IF(H.LT.1.E10)THEN
		    AM0=X0(AK0*H)/H
		ELSE
		    AM0=AK0
		ENDIF
		DO 9731 J=1,IMX
		    ZSB(J)=CMPLX(DNSPERR(1,J),DNSPERM(1,J))
		    ZSS(J)=CMPLX(DNSPERR(2,J),DNSPERM(2,J))
	9731    CONTINUE
	
		DO 7799 KBES=0,NN
	!            PRINT *,'NFAC1',NFAC
	!        IF (IJK==30)PRINT *,SQRT(AK0*G*TANH(AK0*H)),'BLEKLJDLKQJFLK'
		    CSL(1,KBES,IJK)=CL(KBES,ZSB,ZSS,AM0)
		    SSL(1,KBES,IJK)=SL(KBES,ZSB,ZSS,AM0)
	!        PRINT *,'REMPLISAGE I,J,K:',1,KBES,IJK,'   AK0=',AK0
	!            PRINT *,'REMPLISAGE I',1+IJ,CSL(1,KBES,IJK),SSL(1,KBES,IJK)
		IF (IJK==40)KOCHIN=KOCH(ZSB,ZSS,AM0,PI/4.)
	!        PRINT *,(SQRT(XM(I)**2+YM(I)**2),I=1,IMX)
	!      PRINT *,CL(KBES,ZSB,ZSS,AK0)
	!        PRINT *,KBES,ZSB,ZSS,AK0
	7799 CONTINUE
	ENDIF
	7798 CONTINUE
!        PRINT *,ZSB
!!!!!!!!                                                !!!!!!!!!!!!!
!!!     FIN DES COEFFICIENTS DE LA SERIE DES POTENTIELS         !!!!!
!!!!!!!!                                                !!!!!!!!!!!!!

 150   FORMAT(1I3,1X,'|',1X,1F5.3,1X,'|',1X,1F6.1,3(1X,'|',1X,1F5.3))

	!800 AU PIF CAR IL FAUT 100 PAS POUR TROUVER QUE L'INTEGRALE DE COS SUR 0, PI/2 VAUT >=0.99 (1/100 ERREUR)
        ALLOCATE(KPER(N))
        ALLOCATE(KRAD(N))
        ALLOCATE(TABW(N))
        ALLOCATE(TABK(N))
        ERRMAX=0.

        !!PINCP=INTBESSI(1.,THETA,0.)
        !!PINCM=INTBESSI(-1.,THETA,0.)
        PRINT *,'NFACSL+NCONT =',NFACSL+NCONT,'NTOT =',NTOT
        PRINT *,'NO |','   K   |',' LAMBDA |','   W   |',' RDD(K)|',' BETA'
	DO N1=1,N
	        READ(25,REC=N1)TR,BETA,AK0
		OMEG=2*PI/TR
		IF(H.LT.1.E10)THEN
		  AM0=X0(AK0*H)/H
		ELSE
		  AM0=AK0
		ENDIF
		PRINT 150,N1,AM0,2*PI/AM0,2*PI/TR,SQRT(AM0*G*TANH(AM0*H)),BETA
		KRAD(N1)=CONSTR(AM0,H)!FONCTIONS INDEPENDANTES DE THETA (UNIQUEMENT PULSATION)
		KPER(N1)=CONST(AM0,H)!FONCTIONS INDEPENDANTES DE THETA (UNIQUEMENT PULSATION)
		TABW(N1)=2*PI/TR
		TABK(N1)=AM0
	ENDDO
	
!!!!!!!!                                                                                    !!!!!!!!!!!!
!!!   RECONSTITUTION DES POTENTIELS APPROXIME POUR VERIFIER QUE L'ON EST COHERENT ASYMPTOTIQUEMENT  !!!!
!!!!!!!!                                                                                    !!!!!!!!!!!!
	IF (Louthasfs==1) THEN
		WRITE(FMT1,'(I2.2)') NPRINTW1
		WRITE(FMT2,'(I2.2)') NPRINTW2
		WRITE(FMTV,'(I1)') IJPRINT
		OPEN(140,FILE=ID(1:lID)//'/results/QTF/Appendix/POT_ASYMP_W'//TRIM(FMT1)//'_W'//TRIM(FMT2)//'_DOF'//TRIM(FMTV)//'.dat')
		WRITE(140,*) 'X     ','Y     ','PHI1 PARTIE REELLE     ','IM(PHI1)     ','PHI1_X  .._Y  .._Z     ','PHII1 ...','PHIP1 ...','....2','PSIM  .._X  ....','[PSIP .._X ...]'
		OPEN(141,FILE=ID(1:lID)//'/results/QTF/Appendix/LIGNEPOT_ASYMP_W'//TRIM(FMT1)//'_W'//TRIM(FMT2)//'_DOF'//TRIM(FMTV)//'.dat')
		WRITE(141,*) 'X     ','Y     ','PHI1 PARTIE REELLE     ','IM(PHI1)     ','PHI1_X  .._Y  .._Z     ','PHII1 ...','PHIP1 ...','....2','PSIM  .._X  ....','[PSIP .._X ...]'
		OPEN(142,FILE=ID(1:lID)//'/results/QTF/Appendix/PLOT_DZ_INT_ASYMP_W'//TRIM(FMT1)//'_W'//TRIM(FMT2)//'_DOF'//TRIM(FMTV)//'.dat')
		WRITE(142,*) 'X     ','Y     ','INTEGRANDE DZ (S1-3) DIFF SUR LA SL PARTIE RELLE     ','INT DIFF IM     ','[INT SOM RE     ','INT SOM IM]     '
		
		BETA=0.
		W1=TABW(NPRINTW1)
		W2=TABW(NPRINTW2)
		K1=TABK(NPRINTW1)
		K2=TABK(NPRINTW2)
		NPRINTW3=NPRINTW1-NPRINTW2
		WM=W1-W2
		IF (NPRINTW3 /= 0)THEN
			K3=TABK(NPRINTW3)
		ELSE
			K3=0
		ENDIF
		IF (NPRINTW1+NPRINTW2 < N  .AND. LQTFP .EQ. 1) THEN
			NPRINTW4=NPRINTW1+NPRINTW2
			WP=W1+W2
			K4=TABK(NPRINTW4)
		ELSE
			NW4=0
			WP=0
			K4=0
		ENDIF
		IF (LQTFP==0) THEN
			WRITE(140,*) 'W1=',W1,'W2=',W2,'W-=',WM
			WRITE(141,*) 'W1=',W1,'W2=',W2,'W-=',WM
		ELSEIF (LQTFP==1) THEN
			WRITE(140,*) 'W1=',W1,'W2=',W2,'W-=',WM,'W+=',WP
			WRITE(141,*) 'W1=',W1,'W2=',W2,'W-=',WM,'W+=',WP
		ENDIF
		
		DR1=ZI*K1
		DR2=ZI*K2
		DR3=ZI*K3
		DR4=ZI*K4
		KAPP2Mdz=ZI*(W1-W2)*DZ(K1,H)*DZ(K2,H)+ZI*W1*W2/2./G*(W2*DZ(K2,H)-W1*DZ(K1,H))
		KAPP1Mdz=ZI*(W1-W2)*DR1*CONJG(DR2)
		KAPP2Pdz=ZI*(W1-W2)*DZ(K1,H)*DZ(K2,H)+ZI*W1*W2/2./G*(W2*DZ(K2,H)-W1*DZ(K1,H))
		KAPP1Pdz=ZI*(W1-W2)*DR1*CONJG(DR2)

		DO 212 IFACSL=1,NFACSL
		    DO 212 ISYM=1,NJ
			XPOT=XMSLF(IFACSL)
			YPOT=(-1)**(ISYM-1)*YMSLF(IFACSL)
			THETA=ATAN2(YPOT,XPOT)
			FTHETAPER1=INTBESS(1,NPRINTW1,N,CSL,SSL,NN,THETA)
			FTHETAPER2=INTBESS(1,NPRINTW2,N,CSL,SSL,NN,THETA)
			DO 210 IJ=1,6
				FTHETARADM(IJ)=INTBESS(1+IJ,NPRINTW3,N,CSL,SSL,NN,THETA)!2 POUR X, 3 POUR Y ETC..
				IF (LQTFP==1) THEN
					FTHETARADP(IJ)=INTBESS(1+IJ,NPRINTW4,N,CSL,SSL,NN,THETA)!2 POUR X, 3 POUR Y ETC..
				ENDIF
			210  CONTINUE
			LONG=SQRT(XPOT**2+YPOT**2)
			POTPER1=KPER(NPRINTW1)*FTHETAPER1*EXP(ZI*(TABK(NPRINTW1)*LONG))/SQRT(LONG)
			POTPER1_X=POTPER1*DR1*COS(THETA)
			POTPER1_Y=POTPER1*DR1*SIN(THETA)
			POTPER1_Z=POTPER1*DZ(K1,H)
			POTPER2=KPER(NPRINTW2)*FTHETAPER2*EXP(ZI*(TABK(NPRINTW2)*LONG))/SQRT(LONG)
			POTPER2_X=POTPER2*DR2*COS(THETA)
			POTPER2_Y=POTPER2*DR2*SIN(THETA)
			POTPER2_Z=POTPER2*DZ(K2,H)
			
			POTINC1=-G/OMEG*F1(0.,TABK(NPRINTW1),H)*EXP(ZI*TABK(NPRINTW1)*LONG*(COS(THETA-BETA)))
			POTINC1_X=POTINC1*DR1
			POTINC1_Y=0
			POTINC1_Z=POTINC1*DZ(K1,H)
			POTINC2=-G/OMEG*F1(0.,TABK(NPRINTW2),H)*EXP(ZI*TABK(NPRINTW2)*LONG*(COS(THETA-BETA)))
			POTINC2_X=POTINC2*DR2
			POTINC2_Y=0
			POTINC2_Z=POTINC2*DZ(K2,H)
			
			POTTOT1=POTPER1+POTINC1
			POTTOT1_X=POTPER1_X+POTINC1_X
			POTTOT1_Y=POTPER1_Y+POTINC1_Y
			POTTOT1_Z=POTPER1_Z+POTINC1_Z
			POTTOT2=POTPER2+POTINC2
			POTTOT2_X=POTPER2_X+POTINC2_X
			POTTOT2_Y=POTPER2_Y+POTINC2_Y
			POTTOT2_Z=POTPER2_Z+POTINC2_Z
			
			DO 230 IJ=1,6
				POTRADM(IJ)=KRAD(NPRINTW3)*FTHETARADM(IJ)*EXP(ZI*(TABK(NPRINTW3)*LONG))/SQRT(LONG)
				POTRADM_X(IJ)=POTRADM(IJ)*DR3*COS(THETA)
				POTRADM_Y(IJ)=POTRADM(IJ)*DR3*SIN(THETA)
				POTRADM_Z(IJ)=POTRADM(IJ)*DZ(K3,H)
				IF (LQTFP==1) THEN
					POTRADP(IJ)=KRAD(NPRINTW4)*FTHETARADP(IJ)*EXP(ZI*(TABK(NPRINTW4)*LONG))/SQRT(LONG)
					POTRADP_X(IJ)=POTRADP(IJ)*DR4*COS(THETA)
					POTRADP_Y(IJ)=POTRADP(IJ)*DR4*SIN(THETA)
					POTRADP_Z(IJ)=POTRADP(IJ)*DZ(K4,H)
				ENDIF
			230 CONTINUE
			
			INTMdz=-ZI*WM*RHO/G*(POTINC1*CONJG(POTPER2)+POTPER1*CONJG(POTINC2))*(KAPPA1Pdz*COS(THETA-BETA)+KAPPA2Pdz)*POTRAD(3)
            WRITE(142,*) XPOT,YPOT,REAL(INTMdz),AIMAG(INTMdz)
			IF (LQTFP==0) THEN
				WRITE(140,*) XPOT,YPOT &
				& ,REAL(POTTOT1),AIMAG(POTTOT1),REAL(POTTOT1_X),AIMAG(POTTOT1_X),REAL(POTTOT1_Y),AIMAG(POTTOT1_Y),REAL(POTTOT1_Z),AIMAG(POTTOT1_Z) &
				& ,REAL(POTINC1),AIMAG(POTINC1),REAL(POTINC1_X),AIMAG(POTINC1_X),REAL(POTINC1_Y),AIMAG(POTINC1_Y),REAL(POTINC1_Z),AIMAG(POTINC1_Z) &
				& ,REAL(POTPER1),AIMAG(POTPER1),REAL(POTPER1_X),AIMAG(POTPER1_X),REAL(POTPER1_Y),AIMAG(POTPER1_Y),REAL(POTPER1_Z),AIMAG(POTPER1_Z) &
				& ,REAL(POTTOT2),AIMAG(POTTOT2),REAL(POTTOT2_X),AIMAG(POTTOT2_X),REAL(POTTOT2_Y),AIMAG(POTTOT2_Y),REAL(POTTOT2_Z),AIMAG(POTTOT2_Z) &
				& ,REAL(POTINC2),AIMAG(POTINC2),REAL(POTINC2_X),AIMAG(POTINC2_X),REAL(POTINC2_Y),AIMAG(POTINC2_Y),REAL(POTINC2_Z),AIMAG(POTINC2_Z) &
				& ,REAL(POTPER2),AIMAG(POTPER2),REAL(POTPER2_X),AIMAG(POTPER2_X),REAL(POTPER2_Y),AIMAG(POTPER2_Y),REAL(POTPER2_Z),AIMAG(POTPER2_Z) &
				& ,REAL(POTRADM(IJPRINT)),AIMAG(POTRADM(IJPRINT)),REAL(POTRADM_X(IJPRINT)),AIMAG(POTRADM_X(IJPRINT)),REAL(POTRADM_Y(IJPRINT)),AIMAG(POTRADM_Y(IJPRINT)),REAL(POTRADM_Z(IJPRINT)),AIMAG(POTRADM_Z(IJPRINT))
			ELSEIF (LQTFP==1) THEN 
				WRITE(140,*) XPOT,YPOT &
				& ,REAL(POTTOT1),AIMAG(POTTOT1),REAL(POTTOT1_X),AIMAG(POTTOT1_X),REAL(POTTOT1_Y),AIMAG(POTTOT1_Y),REAL(POTTOT1_Z),AIMAG(POTTOT1_Z) &
				& ,REAL(POTINC1),AIMAG(POTINC1),REAL(POTINC1_X),AIMAG(POTINC1_X),REAL(POTINC1_Y),AIMAG(POTINC1_Y),REAL(POTINC1_Z),AIMAG(POTINC1_Z) &
				& ,REAL(POTPER1),AIMAG(POTPER1),REAL(POTPER1_X),AIMAG(POTPER1_X),REAL(POTPER1_Y),AIMAG(POTPER1_Y),REAL(POTPER1_Z),AIMAG(POTPER1_Z) &
				& ,REAL(POTTOT2),AIMAG(POTTOT2),REAL(POTTOT2_X),AIMAG(POTTOT2_X),REAL(POTTOT2_Y),AIMAG(POTTOT2_Y),REAL(POTTOT2_Z),AIMAG(POTTOT2_Z) &
				& ,REAL(POTINC2),AIMAG(POTINC2),REAL(POTINC2_X),AIMAG(POTINC2_X),REAL(POTINC2_Y),AIMAG(POTINC2_Y),REAL(POTINC2_Z),AIMAG(POTINC2_Z) &
				& ,REAL(POTPER2),AIMAG(POTPER2),REAL(POTPER2_X),AIMAG(POTPER2_X),REAL(POTPER2_Y),AIMAG(POTPER2_Y),REAL(POTPER2_Z),AIMAG(POTPER2_Z) &
				& ,REAL(POTRADM(IJPRINT)),AIMAG(POTRADM(IJPRINT)),REAL(POTRADM_X(IJPRINT)),AIMAG(POTRADM_X(IJPRINT)),REAL(POTRADM_Y(IJPRINT)),AIMAG(POTRADM_Y(IJPRINT)),REAL(POTRADM_Z(IJPRINT)),AIMAG(POTRADM_Z(IJPRINT)) &
				& ,REAL(POTRADP(IJPRINT)),AIMAG(POTRADP(IJPRINT)),REAL(POTRADP_X(IJPRINT)),AIMAG(POTRADP_X(IJPRINT)),REAL(POTRADP_Y(IJPRINT)),AIMAG(POTRADP_Y(IJPRINT)),REAL(POTRADP_Z(IJPRINT)),AIMAG(POTRADP_Z(IJPRINT))
			ENDIF
		212 CONTINUE
		CLOSE(140)
		DO 213 IFACSL=1,NLIGNE
			XPOT=XMSLL(IFACSL)
			YPOT=YMSLL(IFACSL)
			THETA=ATAN2(YPOT,XPOT)
			FTHETAPER1=INTBESS(1,NPRINTW1,N,CSL,SSL,NN,THETA)
			FTHETAPER2=INTBESS(1,NPRINTW2,N,CSL,SSL,NN,THETA)
			DO 211 IJ=1,6
				FTHETARADM(IJ)=INTBESS(1+IJ,NPRINTW3,N,CSL,SSL,NN,THETA)!2 POUR X, 3 POUR Y ETC..
				IF (LQTFP==1) THEN
					FTHETARADP(IJ)=INTBESS(1+IJ,NPRINTW4,N,CSL,SSL,NN,THETA)!2 POUR X, 3 POUR Y ETC..
				ENDIF
			211  CONTINUE
			LONG=SQRT(XPOT**2+YPOT**2)
			POTPER1=KPER(NPRINTW1)*FTHETAPER1*EXP(ZI*(TABK(NPRINTW1)*LONG))/SQRT(LONG)
			POTPER1_X=POTPER1*DR1*COS(THETA)
			POTPER1_Y=POTPER1*DR1*SIN(THETA)
			POTPER1_Z=POTPER1*DZ(K1,H)
			POTPER2=KPER(NPRINTW2)*FTHETAPER2*EXP(ZI*(TABK(NPRINTW2)*LONG))/SQRT(LONG)
			POTPER2_X=POTPER2*DR2*COS(THETA)
			POTPER2_Y=POTPER2*DR2*SIN(THETA)
			POTPER2_Z=POTPER2*DZ(K2,H)
			
			POTINC1=-G/OMEG*F1(0.,TABK(NPRINTW1),H)*EXP(ZI*TABK(NPRINTW1)*LONG*(COS(THETA-BETA)))
			POTINC1_X=POTINC1*DR1
			POTINC1_Y=0
			POTINC1_Z=POTINC1*DZ(K1,H)
			POTINC2=-G/OMEG*F1(0.,TABK(NPRINTW2),H)*EXP(ZI*TABK(NPRINTW2)*LONG*(COS(THETA-BETA)))
			POTINC2_X=POTINC2*DR2
			POTINC2_Y=0
			POTINC2_Z=POTINC2*DZ(K2,H)
			
			POTTOT1=POTPER1+POTINC1
			POTTOT1_X=POTPER1_X+POTINC1_X
			POTTOT1_Y=POTPER1_Y+POTINC1_Y
			POTTOT1_Z=POTPER1_Z+POTINC1_Z
			POTTOT2=POTPER2+POTINC2
			POTTOT2_X=POTPER2_X+POTINC2_X
			POTTOT2_Y=POTPER2_Y+POTINC2_Y
			POTTOT2_Z=POTPER2_Z+POTINC2_Z
			
			DO 231 IJ=1,6
				POTRADM(IJ)=KRAD(NPRINTW3)*FTHETARADM(IJ)*EXP(ZI*(TABK(NPRINTW3)*LONG))/SQRT(LONG)
				POTRADM_X(IJ)=POTRADM(IJ)*DR3*COS(THETA)
				POTRADM_Y(IJ)=POTRADM(IJ)*DR3*SIN(THETA)
				POTRADM_Z(IJ)=POTRADM(IJ)*DZ(K3,H)
				IF (LQTFP==1) THEN
					POTRADP(IJ)=KRAD(NPRINTW4)*FTHETARADP(IJ)*EXP(ZI*(TABK(NPRINTW4)*LONG))/SQRT(LONG)
					POTRADP_X(IJ)=POTRADP(IJ)*DR4*COS(THETA)
					POTRADP_Y(IJ)=POTRADP(IJ)*DR4*SIN(THETA)
					POTRADP_Z(IJ)=POTRADP(IJ)*DZ(K4,H)
				ENDIF
			231 CONTINUE
			
			IF (LQTFP==0) THEN
				WRITE(141,*) XPOT,YPOT &
				& ,REAL(POTTOT1),AIMAG(POTTOT1),REAL(POTTOT1_X),AIMAG(POTTOT1_X),REAL(POTTOT1_Y),AIMAG(POTTOT1_Y),REAL(POTTOT1_Z),AIMAG(POTTOT1_Z) &
				& ,REAL(POTINC1),AIMAG(POTINC1),REAL(POTINC1_X),AIMAG(POTINC1_X),REAL(POTINC1_Y),AIMAG(POTINC1_Y),REAL(POTINC1_Z),AIMAG(POTINC1_Z) &
				& ,REAL(POTPER1),AIMAG(POTPER1),REAL(POTPER1_X),AIMAG(POTPER1_X),REAL(POTPER1_Y),AIMAG(POTPER1_Y),REAL(POTPER1_Z),AIMAG(POTPER1_Z) &
				& ,REAL(POTTOT2),AIMAG(POTTOT2),REAL(POTTOT2_X),AIMAG(POTTOT2_X),REAL(POTTOT2_Y),AIMAG(POTTOT2_Y),REAL(POTTOT2_Z),AIMAG(POTTOT2_Z) &
				& ,REAL(POTINC2),AIMAG(POTINC2),REAL(POTINC2_X),AIMAG(POTINC2_X),REAL(POTINC2_Y),AIMAG(POTINC2_Y),REAL(POTINC2_Z),AIMAG(POTINC2_Z) &
				& ,REAL(POTPER2),AIMAG(POTPER2),REAL(POTPER2_X),AIMAG(POTPER2_X),REAL(POTPER2_Y),AIMAG(POTPER2_Y),REAL(POTPER2_Z),AIMAG(POTPER2_Z) &
				& ,REAL(POTRADM(IJPRINT)),AIMAG(POTRADM(IJPRINT)),REAL(POTRADM_X(IJPRINT)),AIMAG(POTRADM_X(IJPRINT)),REAL(POTRADM_Y(IJPRINT)),AIMAG(POTRADM_Y(IJPRINT)),REAL(POTRADM_Z(IJPRINT)),AIMAG(POTRADM_Z(IJPRINT))
			ELSEIF (LQTFP==1) THEN 
				WRITE(141,*) XPOT,YPOT &
				& ,REAL(POTTOT1),AIMAG(POTTOT1),REAL(POTTOT1_X),AIMAG(POTTOT1_X),REAL(POTTOT1_Y),AIMAG(POTTOT1_Y),REAL(POTTOT1_Z),AIMAG(POTTOT1_Z) &
				& ,REAL(POTINC1),AIMAG(POTINC1),REAL(POTINC1_X),AIMAG(POTINC1_X),REAL(POTINC1_Y),AIMAG(POTINC1_Y),REAL(POTINC1_Z),AIMAG(POTINC1_Z) &
				& ,REAL(POTPER1),AIMAG(POTPER1),REAL(POTPER1_X),AIMAG(POTPER1_X),REAL(POTPER1_Y),AIMAG(POTPER1_Y),REAL(POTPER1_Z),AIMAG(POTPER1_Z) &
				& ,REAL(POTTOT2),AIMAG(POTTOT2),REAL(POTTOT2_X),AIMAG(POTTOT2_X),REAL(POTTOT2_Y),AIMAG(POTTOT2_Y),REAL(POTTOT2_Z),AIMAG(POTTOT2_Z) &
				& ,REAL(POTINC2),AIMAG(POTINC2),REAL(POTINC2_X),AIMAG(POTINC2_X),REAL(POTINC2_Y),AIMAG(POTINC2_Y),REAL(POTINC2_Z),AIMAG(POTINC2_Z) &
				& ,REAL(POTPER2),AIMAG(POTPER2),REAL(POTPER2_X),AIMAG(POTPER2_X),REAL(POTPER2_Y),AIMAG(POTPER2_Y),REAL(POTPER2_Z),AIMAG(POTPER2_Z) &
				& ,REAL(POTRADM(IJPRINT)),AIMAG(POTRADM(IJPRINT)),REAL(POTRADM_X(IJPRINT)),AIMAG(POTRADM_X(IJPRINT)),REAL(POTRADM_Y(IJPRINT)),AIMAG(POTRADM_Y(IJPRINT)),REAL(POTRADM_Z(IJPRINT)),AIMAG(POTRADM_Z(IJPRINT)) &
				& ,REAL(POTRADP(IJPRINT)),AIMAG(POTRADP(IJPRINT)),REAL(POTRADP_X(IJPRINT)),AIMAG(POTRADP_X(IJPRINT)),REAL(POTRADP_Y(IJPRINT)),AIMAG(POTRADP_Y(IJPRINT)),REAL(POTRADP_Z(IJPRINT)),AIMAG(POTRADP_Z(IJPRINT))
			ENDIF
		213 CONTINUE
		CLOSE(141)
	ENDIF
	
!!!!!!!!                                                !!!!!!!!!!!!!
!!!                 FIN DES CALCULS INUTILES                    !!!!!
!!!!!!!!                                                !!!!!!!!!!!!!

        !!!!!LES FONCTIONS DE BESSEL SONT BONNES!!!!!!

!!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
!~         ALLOCATE(EFFSLM(6,NHASKIND,NHASKIND,NRCER))
!~ 	IF (LQTFP .EQ. 1) THEN
!~ 		ALLOCATE(EFFSLP(6,NHASKIND,NHASKIND,NRCER))
!~ 	ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!!
        ALLOCATE(EFFSLM(6,N,N,NRCER))
	IF (LQTFP .EQ. 1) THEN
		ALLOCATE(EFFSLP(6,N,N,NRCER))
	ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	

	PRINT *, ">ATTENTION, LES FCT DE BESSELS DOIVENT ETRE TABLES JUSQU'A X=",RCER(NRCER)*MAXVAL(TABK)!~         PRINT *, ">ATTENTION, LES FCT DE BESSELS DOIVENT ETRE TABLES JUSQU'A X=",(RCEREXT+10.)*MAXVAL(TABK)
        PRINT *, ">ATTENTION AU NOMBRE DE FONCTION DE BESSEL, OU UNE APPROXIMATION SERA FAUSSE "
        PRINT *, "EXP^{(I K R COS(THETA-BETA))} = SUM_J QQCH * J_J(K R) COS(J(THETA - BETA))"
        PRINT *, "CE QUI EST NECESSAIRE POUR CETTE PARTIE ASYMPTOTIQUE."
        PRINT *, "POUR VOTRE PULSATION, SE REFERER A L'IMAGE 'FONCTION DE BESS MIN POUR TRONCATURE SERIE'"
        PRINT *, "CELA VOUS DONNERA L'ERREUR COMMISE EN FONCTION DU NOMBRE DE FCT DE BESS"
        PRINT *,' '
        PRINT *, ">VOS VALEURS:"
        PRINT *, " -----------------------------------"
        PRINT *,'|NOMBRE FCTS BESS=',NN,'     |'
	PRINT *,'|K.R             =',RCER(NRCER)*MAXVAL(TABK),'|'!~         PRINT *,'|K.R             =',(RCEREXT+10)*MAXVAL(TABK),'|'
        PRINT *, " -----------------------------------"
        PRINT *,' '
        PRINT *,'>ATTENTION, IL EST RECOMMANDE DE SE PLACER EN RCEREXT, TQ RCEREXT>3 LAMBDA MAX, IE'
        PRINT *,'RCEREXT=',RCER(NRCER),'>',3*2*PI/(MINVAL(TABK)),'=3* LAMBDA MAX'



	IF (Louthasfs==1) THEN	
		OPEN(215,FILE=ID(1:lID)//'/results/QTF/Appendix/ISLM_DZ_ASYMP_W'//TRIM(FMT1)//'_W'//TRIM(FMT2)//'_DOF'//TRIM(FMTV)//'.dat')
		OPEN(216,FILE=ID(1:lID)//'/results/QTF/Appendix/ISLM_DZZ_ASYMP_W'//TRIM(FMT1)//'_W'//TRIM(FMT2)//'_DOF'//TRIM(FMTV)//'.dat')
		WRITE(215,*) 'Rext    ','REAL PART DZ INTM    ','IM DZ INTM','[RE DZ INTP    ','IM DZ INTP]'
		WRITE(216,*) 'Rext    ','REAL PART DZZ INTM    ','IM DZZ INTM','[RE DZZ INTP    ','IM DZZ INTP]'
		IF (LQTFP==0) THEN
			WRITE(215,*) 'W1=',W1,'W2=',W2,'W-=',WM
			WRITE(216,*) 'W1=',W1,'W2=',W2,'W-=',WM
		ELSEIF (LQTFP==1) THEN
			WRITE(215,*) 'W1=',W1,'W2=',W2,'W-=',WM,'W+=',WP
			WRITE(216,*) 'W1=',W1,'W2=',W2,'W-=',WM,'W+=',WP
		ENDIF
	ENDIF
	
!!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
!~ 	ALLOCATE(CST1M(NHASKIND,NHASKIND))
!~ 	ALLOCATE(CST2M(NHASKIND,NHASKIND))
!~ 	ALLOCATE(CST1P(NHASKIND,NHASKIND))
!~ 	ALLOCATE(CST2P(NHASKIND,NHASKIND))
!~ 	ALLOCATE(KAPPA1M0(NHASKIND,NHASKIND))
!~ 	ALLOCATE(KAPPA2M0(NHASKIND,NHASKIND))
!~ 	ALLOCATE(KAPPA1P0(NHASKIND,NHASKIND))
!~ 	ALLOCATE(KAPPA2P0(NHASKIND,NHASKIND))
!~ 	ALLOCATE(INTDIFF1M(0:NN,NRCER,NHASKIND,NHASKIND))
!~ 	ALLOCATE(INTDIFF2M(0:NN,NRCER,NHASKIND,NHASKIND))
!~ 	ALLOCATE(INTDIFF1P(0:NN,NRCER,NHASKIND,NHASKIND))
!~ 	ALLOCATE(INTDIFF2P(0:NN,NRCER,NHASKIND,NHASKIND))
!~ 	ALLOCATE(LAMBDAN1M(0:NN,NHASKIND,NHASKIND))
!~ 	ALLOCATE(LAMBDAN2M(0:NN,NHASKIND,NHASKIND))
!~ 	ALLOCATE(LAMBDAN1P(0:NN,NHASKIND,NHASKIND))
!~ 	ALLOCATE(LAMBDAN2P(0:NN,NHASKIND,NHASKIND))
!~ 	ALLOCATE(U1JM(-1:NN+1,6,NHASKIND,NHASKIND))
!~ 	ALLOCATE(U2JM(-1:NN+1,6,NHASKIND,NHASKIND))
!~ 	ALLOCATE(U1JP(-1:NN+1,6,NHASKIND,NHASKIND))
!~ 	ALLOCATE(U2JP(-1:NN+1,6,NHASKIND,NHASKIND))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!!
	ALLOCATE(CST1M(N,N))
	ALLOCATE(CST2M(N,N))
	ALLOCATE(CST1P(N,N))
	ALLOCATE(CST2P(N,N))
	ALLOCATE(KAPPA1M0(N,N))
	ALLOCATE(KAPPA2M0(N,N))
	ALLOCATE(KAPPA1P0(N,N))
	ALLOCATE(KAPPA2P0(N,N))
	ALLOCATE(INTDIFF1M(0:NN,NRCER,N,N))
	ALLOCATE(INTDIFF2M(0:NN,NRCER,N,N))
	ALLOCATE(INTDIFF1P(0:NN,NRCER,N,N))
	ALLOCATE(INTDIFF2P(0:NN,NRCER,N,N))
	ALLOCATE(LAMBDAN1M(0:NN,N,N))
	ALLOCATE(LAMBDAN2M(0:NN,N,N))
	ALLOCATE(LAMBDAN1P(0:NN,N,N))
	ALLOCATE(LAMBDAN2P(0:NN,N,N))
	ALLOCATE(U1JM(-1:NN+1,6,N,N))
	ALLOCATE(U2JM(-1:NN+1,6,N,N))
	ALLOCATE(U1JP(-1:NN+1,6,N,N))
	ALLOCATE(U2JP(-1:NN+1,6,N,N))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	CST1M=0
	CST2M=0
	CST1P=0
	CST2P=0
	KAPPA1M0=0
	KAPPA2M0=0
	KAPPA1P0=0
	KAPPA2P0=0
	INTDIFF1M=0
	INTDIFF2M=0
	INTDIFF1P=0
	INTDIFF2P=0
	LAMBDAN1M=0
	LAMBDAN2M=0
	LAMBDAN1P=0
	LAMBDAN2P=0
	U1JM=0
	U2JM=0
	U1JP=0
	U2JP=0
	
	
!~ 	DO 500 NW1=1,NHASKIND						! version matrice carre pour les QTF+
	DO 500 NW1=1,N							! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs)
            DO 500 NW2=1,NW1
		WRITE(*,1987,ADVANCE="NO") NW1,NW2,1,0.,CHAR(13)

                BETA=0.
                W1=TABW(NW1)
                W2=TABW(NW2)
                K1=TABK(NW1)
                K2=TABK(NW2)
		NW3=NW1-NW2
		WM=W1-W2
		! sur la diagonale, les QTF- haskind sont nulles
		IF (NW3/=0) THEN
			K3=TABK(NW3)
		ELSE
			K3=0
		ENDIF
		
		IF (NW1+NW2 <= N  .AND. LQTFP .EQ. 1) THEN
			NW4=NW1+NW2
			WP=W1+W2
			K4=TABK(NW4)
		ELSE
			NW4=0
			WP=NAN
			K4=NAN
		ENDIF
                DR1=ZI*K1
                DR2=ZI*K2
		
		!!!!!!! dz + dzz !!!
		KAPPA2M0(NW1,NW2)=ZI*(W1-W2)*DZ(K1,H)*DZ(K2,H)+ZI*W1*W2/2.*(F3(K1,W1,H)-F3(K2,W2,H))
		KAPPA2P0(NW1,NW2)=ZI*(W1+W2)*DZ(K1,H)*DZ(K2,H)-ZI*W1*W2/2.*(F3(K1,W1,H)+F3(K2,W2,H))
		KAPPA1M0(NW1,NW2)=ZI*(W1-W2)*DR1*CONJG(DR2)
		KAPPA1P0(NW1,NW2)=ZI*(W1+W2)*DR1*DR2
		
		!!!!!!!!!!!!!!!!!!!!
		
		IF (NW1==NPRINTW1 .AND. NW2==NPRINTW2 .AND. Louthasfs==1 ) THEN
			!!!!!!! dzz !!!!!!!!
			KAPPA2Mdzz=ZI*W1*W2/2.*(F3(K1,W1,H)+W1*DZ(K1,H)/G-F3(K2,W2,H)-W2*DZ(K2,H)/G)  
			KAPPA1Mdzz=0
			KAPPA2Pdzz=-ZI*W1*W2/2.*(F3(K1,W1,H)+W1*DZ(K1,H)/G+F3(K2,W2,H)+W2*DZ(K2,H)/G)  
			KAPPA1Pdzz=0
			!!!!!!!!!!!!!!!!!!!!
			!!!!!!! dz !!!
			KAPPA2Mdz=ZI*(W1-W2)*DZ(K1,H)*DZ(K2,H)+ZI*W1*W2/2.*(W2*DZ(K2,H)/G-W1*DZ(K1,H)/G)
			KAPPA1Mdz=ZI*(W1-W2)*DR1*CONJG(DR2)
			KAPPA2Pdz=ZI*(W1+W2)*DZ(K1,H)*DZ(K2,H)+ZI*W1*W2/2.*(W2*DZ(K2,H)/G+W1*DZ(K1,H)/G)
			KAPPA1Pdz=ZI*(W1+W2)*DR1*CONJG(DR2)
			!!!!!!!!!!!!!!!!!!!!
		ENDIF
		
		
		! ATTENTION ZI --> POUR COMPENSER LE exp(i*pi/2) EN ABSENT DES VJ EN SOMME DE NOMBRE D'ONDE
                                                                        !DE CETTE FACON CSTI * SUMI=
		IF (Nw3/=0) THEN
			CST1M(NW1,NW2)=(-G/W1)*MK(K2,0.,H)*MK(K3,0.,H)        ! IINT PHII1 PHIP2* PSI DS C'EST AUSSI = 1/(DZ1 DZ2*) IINT PHII1,Z PHIP2*,Z PSI DS
			CST2M(NW1,NW2)=(-G/W2)*ZI*MK(K1,0.,H)*MK(K3,0.,H)     ! IINT PHIP1 PHII2* PSI DS C'EST AUSSI = 1/(DZ1 DZ2*) IINT PHIP1,Z PHII2*,Z PSI DS
		ELSE
			CST1M(NW1,NW2)=NAN
			CST2M(NW1,NW2)=NAN
		ENDIF
		IF (NW4/=0) THEN
			CST1P(NW1,NW2)=(-G/W1)*ZI*MK(K2,0.,H)*MK(K4,0.,H)     		! IINT PHII1 PHIP2* PSI DS C'EST AUSSI = 1/(DZ1 DZ2*) IINT PHII1,Z PHIP2*,Z PSI DS
			CST2P(NW1,NW2)=(-G/W2)*ZI*MK(K1,0.,H)*MK(K4,0.,H)     		! IINT PHIP1 PHII2* PSI DS C'EST AUSSI = 1/(DZ1 DZ2*) IINT PHIP1,Z PHII2*,Z PSI DS
		ELSE
			CST1P(NW1,NW2)=NAN
			CST2P(NW1,NW2)=NAN
		ENDIF
		
		
		
		DO 2100 J=-1,NN+1
		    DO 2100 IJ=1,6,DOFSYM
			IF (NW3/=0) THEN
				U1JM(J,IJ,NW1,NW2)=  KJ(J,IJ,CSL,SSL,NN,N,BETA,NW2,NW3)
				U2JM(J,IJ,NW1,NW2)=KJPR(J,IJ,CSL,SSL,NN,N,BETA,NW1,NW3)
			ELSE
				U1JM(J,IJ,NW1,NW2)=NAN
				U2JM(J,IJ,NW1,NW2)=NAN
			ENDIF
			IF (NW4/=0) THEN
				U1JP(J,IJ,NW1,NW2)=KJPR(J,IJ,CSL,SSL,NN,N,BETA,NW2,NW4)
				U2JP(J,IJ,NW1,NW2)=KJPR(J,IJ,CSL,SSL,NN,N,BETA,NW1,NW4)
			ELSE
				U1JP(J,IJ,NW1,NW2)=NAN
				U2JP(J,IJ,NW1,NW2)=NAN
			ENDIF
		2100 CONTINUE
			
			
		DO 2150 J=0,NN
			IF (NW3/=0) THEN
				LAMBDAN1M(J,NW1,NW2)=LAMBDAN(J,K3-K2,K1)
				LAMBDAN2M(J,NW1,NW2)=LAMBDAN(J,K3+K1,K2)
			ELSE
				LAMBDAN1M(J,NW1,NW2)=NAN
				LAMBDAN2M(J,NW1,NW2)=NAN
			ENDIF
			IF (NW4/=0) THEN
				LAMBDAN1P(J,NW1,NW2)=LAMBDAN(J,K4+K2,K1)
				LAMBDAN2P(J,NW1,NW2)=LAMBDAN(J,K4+K1,K2)
			ELSE
				LAMBDAN1P(J,NW1,NW2)=NAN
				LAMBDAN2P(J,NW1,NW2)=NAN
			ENDIF
			
			RAYINT=0
			DO 2150 ICER=1,NRCER
			    RAY0=RAYINT
			    RAYINT=RCER(ICER)*COS(PI/NTHETA/NJ)		! PRENDS EN COMPTE LA DISCRETISATION DU CERCLE EXT
			    NR=MAX(3,INT(130*(RAYINT-RAY0)/(2*PI/MAX(K1,K2,K3)))) !!TROUVER UNE FORMULE POUR OPTIMISER
			    DRAY=(RAYINT-RAY0)/FLOAT(NR)
			    
!~ 			    WRITE(*,1987,ADVANCE="NO") NW1,NW2,IJ,RAYINT,CHAR(13)
			    
			    IF (ICER>1) THEN
				IF (NW3/=0) THEN
					INTDIFF1M(J,ICER,NW1,NW2)=INTDIFF1M(J,ICER-1,NW1,NW2)
					INTDIFF2M(J,ICER,NW1,NW2)=INTDIFF2M(J,ICER-1,NW1,NW2)
				ELSE
					INTDIFF1M(J,ICER,NW1,NW2)=NAN
					INTDIFF2M(J,ICER,NW1,NW2)=NAN
				ENDIF
				IF (NW4/=0) THEN
					INTDIFF1P(J,ICER,NW1,NW2)=INTDIFF1P(J,ICER-1,NW1,NW2)
					INTDIFF2P(J,ICER,NW1,NW2)=INTDIFF2P(J,ICER-1,NW1,NW2)
				ELSE
					INTDIFF1P(J,ICER,NW1,NW2)=NAN
					INTDIFF2P(J,ICER,NW1,NW2)=NAN
				ENDIF
			    ENDIF
			    DO 2150 IR=0,NR-1
!RAYON EN DESSOUS DUQUEL ON EXPRIME L'INTEGRALE DE VJ.
!EN EFFET, LA PARTIE INTEGREE EST DE 0 A L'INFINI, ON DOIT DONC ENLEVER L'ENTEGRALE ENTRE 0 ET RAYINT
				RAY=RAY0+FLOAT(IR)/FLOAT(NR)*(RAYINT-RAY0)
				RAY2=RAY0+(FLOAT(IR)+1.)/FLOAT(NR)*(RAYINT-RAY0)
			    
				! APBES(n,x) = Jn(xi-1) + Jn'(xi-1)*(x-xi-1)
				!			xi-1 < x < xi
				! attention k3+k1 --> + pi/2 : OK CF CST4M
				! 

				IF (NW3/=0) THEN
					INTDIFF1M(J,ICER,NW1,NW2)=INTDIFF1M(J,ICER,NW1,NW2)	&
					& + 0.5*(APBES(J,K1*RAY )*EXP(ZI*((K3-K2)*RAY ))	&
					&	+APBES(J,K1*RAY2)*EXP(ZI*((K3-K2)*RAY2)))	&
					&*DRAY
	
					INTDIFF2M(J,ICER,NW1,NW2)=INTDIFF2M(J,ICER,NW1,NW2)	&
					& + 0.5*(APBES(J,K2*RAY )*EXP(ZI*((K3+K1)*RAY ))	&
					&	+APBES(J,K2*RAY2)*EXP(ZI*((K3+K1)*RAY2)))	&
					&*DRAY
				ELSE
					INTDIFF1M(J,ICER,NW1,NW2)=NAN
					INTDIFF2M(J,ICER,NW1,NW2)=NAN
				ENDIF
				IF (NW4/=0) THEN
				    INTDIFF1P(J,ICER,NW1,NW2)=INTDIFF1P(J,ICER,NW1,NW2)	&
				    & + 0.5*(APBES(J,K1*RAY )*EXP(ZI*((K4+K2)*RAY ))	&
				    &	    +APBES(J,K1*RAY2)*EXP(ZI*((K4+K2)*RAY2)))	&
				    &*DRAY
	
				    INTDIFF2P(J,ICER,NW1,NW2)=INTDIFF2P(J,ICER,NW1,NW2)	&
				    & + 0.5*(APBES(J,K2*RAY )*EXP(ZI*((K4+K1)*RAY ))	&
				    &	    +APBES(J,K2*RAY2)*EXP(ZI*((K4+K1)*RAY2)))	&
				    &*DRAY
	
				ELSE
				    INTDIFF1P(J,ICER,NW1,NW2)=NAN
				    INTDIFF2P(J,ICER,NW1,NW2)=NAN
				ENDIF
			    
		2150 CONTINUE

			

			

		DO 500 ICER=1,NRCER
		DO 500 IJ=1,6,DOFSYM
		    
		    
		    SUM1M=0
		    SUM2M=0
		    SUM3M=0
		    SUM4M=0
		    SUM1P=0
		    SUM2P=0
		    SUM3P=0
		    SUM4P=0
		    
!~ 		    WRITE(*,1987,ADVANCE="NO") NW1,NW2,IJ,RCER(ICER),CHAR(13)
		    
		    DO 2152 J=0,NN
		    
                        IF (NW3/=0) THEN
				SUM1M=SUM1M+EPS(J)*( ZI)**J*(LAMBDAN1M(J,NW1,NW2)-INTDIFF1M(J,ICER,NW1,NW2))*U1JM(J,IJ,NW1,NW2)
				SUM2M=SUM2M+EPS(J)*(-ZI)**J*(LAMBDAN2M(J,NW1,NW2)-INTDIFF2M(J,ICER,NW1,NW2))*U2JM(J,IJ,NW1,NW2)
				SUM3M=SUM3M+EPS(J)*( ZI)**J*(LAMBDAN1M(J,NW1,NW2)-INTDIFF1M(J,ICER,NW1,NW2))*(U1JM(J+1,IJ,NW1,NW2)+U1JM(J-1,IJ,NW1,NW2))/2.
				SUM4M=SUM4M+EPS(J)*(-ZI)**J*(LAMBDAN2M(J,NW1,NW2)-INTDIFF2M(J,ICER,NW1,NW2))*(U2JM(J+1,IJ,NW1,NW2)+U2JM(J-1,IJ,NW1,NW2))/2.
			ELSE
				SUM1M=NAN
				SUM2M=NAN
				SUM3M=NAN
				SUM4M=NAN
			ENDIF
			IF (NW4/=0) THEN
				SUM1P=SUM1P+EPS(J)*(ZI)**J*(LAMBDAN1P(J,NW1,NW2)-INTDIFF1P(J,ICER,NW1,NW2))*U1JP(J,IJ,NW1,NW2)
				SUM2P=SUM2P+EPS(J)*(ZI)**J*(LAMBDAN2P(J,NW1,NW2)-INTDIFF2P(J,ICER,NW1,NW2))*U2JP(J,IJ,NW1,NW2)
				SUM3P=SUM3P+EPS(J)*(ZI)**J*(LAMBDAN1P(J,NW1,NW2)-INTDIFF1P(J,ICER,NW1,NW2))*(U1JP(J+1,IJ,NW1,NW2)+U1JP(J-1,IJ,NW1,NW2))/2.
				SUM4P=SUM4P+EPS(J)*(ZI)**J*(LAMBDAN2P(J,NW1,NW2)-INTDIFF2P(J,ICER,NW1,NW2))*(U2JP(J+1,IJ,NW1,NW2)+U2JP(J-1,IJ,NW1,NW2))/2.
			ELSE
				SUM1P=NAN
				SUM2P=NAN
				SUM3P=NAN
				SUM4P=NAN
			ENDIF

                    2152 CONTINUE
                    
!	les 3 expressions de ISL sont identiques    
		    IF (NW3/=0) THEN
			ISLM_0=&
			&   SUM1M*CST1M(NW1,NW2)*KAPPA2M0(NW1,NW2)	&
			&  +SUM2M*CST2M(NW1,NW2)*KAPPA2M0(NW1,NW2)	&
			&  +SUM3M*CST1M(NW1,NW2)*KAPPA1M0(NW1,NW2)	&
			&  +SUM4M*CST2M(NW1,NW2)*KAPPA1M0(NW1,NW2)
		    ELSE 
			ISLM_0=NAN
		    ENDIF
		    IF (NW4 /=0) THEN
		    
			ISLP_0=& 
			&   SUM1P*CST1P(NW1,NW2)*KAPPA2P0(NW1,NW2)	&
			&  +SUM2P*CST2P(NW1,NW2)*KAPPA2P0(NW1,NW2)	&
			&  +SUM3P*CST1P(NW1,NW2)*KAPPA1P0(NW1,NW2)	&
			&  +SUM4P*CST2P(NW1,NW2)*KAPPA1P0(NW1,NW2)
			
		    ELSE
			ISLP_0=NAN
		    ENDIF
                    
		    IF (NW1==NPRINTW1 .AND. NW2==NPRINTW2 .AND. IJ==IJPRINT .AND. Louthasfs==1 ) THEN
			IF (NW3/=0) THEN
				ISLM_DZ=-ZI*WM*RHO/G*(		&
				&   SUM1M*CST1M(NW1,NW2)*KAPPA2Mdz	&
				&  +SUM2M*CST2M(NW1,NW2)*KAPPA2Mdz	&
				&  +SUM3M*CST1M(NW1,NW2)*KAPPA1Mdz	&
				&  +SUM4M*CST2M(NW1,NW2)*KAPPA1Mdz)
				
				ISLM_DZZ=-ZI*WM*RHO/G*(			&
				&   SUM1M*CST1M(NW1,NW2)*KAPPA2Mdzz	&
				&  +SUM2M*CST2M(NW1,NW2)*KAPPA2Mdzz	&
				&  +SUM3M*CST1M(NW1,NW2)*KAPPA1Mdzz	&
				&  +SUM4M*CST2M(NW1,NW2)*KAPPA1Mdzz)
			ELSE
				ISLM_DZ=0.
				ISLM_DZZ=0.
			ENDIF
			IF (NW4 /= 0) THEN
			
				ISLP_DZ=-ZI*WP*RHO/G*(		&
				&   SUM1P*CST1P(NW1,NW2)*KAPPA2Pdz	&
				&  +SUM2P*CST2P(NW1,NW2)*KAPPA2Pdz	&
				&  +SUM3P*CST1P(NW1,NW2)*KAPPA1Pdz	&
				&  +SUM4P*CST2P(NW1,NW2)*KAPPA1Pdz)
				
				ISLP_DZZ=-ZI*WM*RHO/G*(			&
				&   SUM1P*CST1P(NW1,NW2)*KAPPA2Pdzz	&
				&  +SUM2P*CST2P(NW1,NW2)*KAPPA2Pdzz	&
				&  +SUM3P*CST1P(NW1,NW2)*KAPPA1Pdzz	&
				&  +SUM4P*CST2P(NW1,NW2)*KAPPA1Pdzz)
				
                WRITE(215,*) RCER(ICER),REAL(ISLM_DZ ),AIMAG(ISLM_DZ ),REAL(ISLP_DZ ),AIMAG(ISLP_DZ ) 
                WRITE(216,*) RCER(ICER),REAL(ISLM_DZZ),AIMAG(ISLM_DZZ),REAL(ISLP_DZZ),AIMAG(ISLP_DZZ)
			ELSE
			
                WRITE(215,*) RCER(ICER),REAL(ISLM_DZ ),AIMAG(ISLM_DZ )
                WRITE(216,*) RCER(ICER),REAL(ISLM_DZZ),AIMAG(ISLM_DZZ)
			ENDIF
                    ENDIF
                    

		    !!!  QTFij-=QTFji-* !!!
		    ! ON PREND LE CONJUGE DU TRIANGLE SUP
		    IF (NW3/=0) THEN
			EFFSLM(IJ,NW1,NW2,ICER)=-ZI*WM*RHO/G*ISLM_0
			EFFSLM(IJ,NW2,NW1,ICER)=CONJG(-ZI*WM*RHO/G*ISLM_0)
		    ELSE
			EFFSLM(IJ,NW1,NW2,ICER)=0.
			EFFSLM(IJ,NW2,NW1,ICER)=0.
		    ENDIF
		    IF (LQTFP .EQ. 1) THEN
			!!!  QTFij+=QTFji+ !!!
			IF (NW4/=0) THEN    
			    EFFSLP(IJ,NW1,NW2,ICER)=-ZI*WP*RHO/G*ISLP_0
			    EFFSLP(IJ,NW2,NW1,ICER)=-ZI*WP*RHO/G*ISLP_0
			ELSE    
			    EFFSLP(IJ,NW1,NW2,ICER)=0.
			    EFFSLP(IJ,NW2,NW1,ICER)=0.
			ENDIF
		    ENDIF
!!!!!!!!!!!!!!!!!                                               !!!!!!!!!!!!!!!!!!!
!!!!!!     FIN VRAI PROGRAMME FINAL QUI CALCULE VRAIMENT CE QUE L'ON SOUHAITE  !!!!
!!!!!!!!!!!!!!!!!                                               !!!!!!!!!!!!!!!!!!!

		
        500 CONTINUE
	
	IF (Louthasfs==1) CLOSE(215); CLOSE(216)
	IF (LQTFP .EQ. 1 .AND. Louthasfs==1)  CLOSE(217);CLOSE(218)
	
	WRITE(*,*)
	WRITE(*,*) 'BOUCLE FINIE'
	
	WRITE(*,*) 'QTF- CALCULEES POUR W- = 0 --> ',TABW(N-1)
	IF (LQTFP==1) THEN
		WRITE(*,*) 'QTF+ CALCULEES POUR W+ = ',TABW(2),' --> ',TABW(N)
	ENDIF
      
      
1991 FORMAT(1F9.3,4000(3X,1E13.6))
!~ 1989 FORMAT('QTF-',4000(1F13.3,3X))
1989 FORMAT(1F9.3,4000(1F9.3,3X))
!250 FORMAT('W2:',1F4.2,1X,'THETA:',1F4.2,1X,'ITER CONV:',1I5,1X,'LONG CONV:',1ES8.2)
1987 FORMAT('INTEGRATION: NW1 =',1I2,', NW2 =',1I2,',DOF =',1I1,', RCER =',1F5.0,1A1)

!ECRITURE
    DO 410 IJ=1,6,DOFSYM
        IJK=400+IJ
	WRITE(FMTV,'(I1)')IJ
        IJKI=400+6+IJ
	IF (LQTFP .EQ. 1) THEN
		IJKJ=400+12+IJ
		IJKK=400+18+IJ
	ENDIF
        OPEN(UNIT=IJK,FILE=ID(1:lID)//'/results/QTF/QTFM_ASYMP_DOF_'//TRIM(FMTV)//'_PR.dat')
        OPEN(UNIT=IJKI,FILE=ID(1:lID)//'/results/QTF/QTFM_ASYMP_DOF_'//TRIM(FMTV)//'_PI.dat')
	IF (LQTFP .EQ. 1) THEN
		OPEN(UNIT=IJKJ,FILE=ID(1:lID)//'/results/QTF/QTFP_ASYMP_DOF_'//TRIM(FMTV)//'_PR.dat')
		OPEN(UNIT=IJKK,FILE=ID(1:lID)//'/results/QTF/QTFP_ASYMP_DOF_'//TRIM(FMTV)//'_PI.dat')
	ENDIF

!!!!!!! Permet de sortir les QTF à chaque rayons -> PAS UTILE
! 	DO 400 ICER=1,NRCER
! !!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
! !~ 		WRITE(IJK,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
! !~ 		WRITE(IJKI,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
! !~ 		IF (LQTFP .EQ. 1) THEN
! !~ 			WRITE(IJKJ,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
! !~ 			WRITE(IJKK,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
! !~ 		ENDIF
! !~ 		DO 400 NW2=1,NHASKIND
! !~ 			WRITE(IJK,1991)  TABW(NW2),(REAL(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
! !~ 			WRITE(IJKI,1991) TABW(NW2),(IMAG(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
! !~ 			IF (LQTFP .EQ. 1) THEN
! !~ 				WRITE(IJKJ,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
! !~ 				WRITE(IJKK,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
! !~ 			ENDIF
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!
! 		WRITE(IJK,1989) RCER(ICER),(TABW(NW1),NW1=1,N)
! 		WRITE(IJKI,1989) RCER(ICER),(TABW(NW1),NW1=1,N)
! 		IF (LQTFP .EQ. 1) THEN
! 			WRITE(IJKJ,1989) RCER(ICER),(TABW(NW1),NW1=1,N)
! 			WRITE(IJKK,1989) RCER(ICER),(TABW(NW1),NW1=1,N)
! 		ENDIF
! 		DO 400 NW2=1,N
! 			WRITE(IJK,1991)  TABW(NW2),(REAL(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,N)
! 			WRITE(IJKI,1991) TABW(NW2),(IMAG(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,N)
! 			IF (LQTFP .EQ. 1) THEN
! 				WRITE(IJKJ,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,N)
! 				WRITE(IJKK,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,N)
! 			ENDIF
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     400 CONTINUE


!!!!!!! Ecrire les QTF que pour RMAX -> ICER = NRCER

!!!!!!!!!!!!!! version matrice carre pour les QTF+!!!!!!!!!!!!!!!!!!!!!!
!~      WRITE(IJK,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
!~      WRITE(IJKI,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
!~      IF (LQTFP .EQ. 1) THEN
!~          WRITE(IJKJ,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
!~          WRITE(IJKK,1989) RCER(ICER),(TABW(NW1),NW1=1,NHASKIND)
!~      ENDIF
!~      DO 400 NW2=1,NHASKIND
!~          WRITE(IJK,1991)  TABW(NW2),(REAL(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
!~          WRITE(IJKI,1991) TABW(NW2),(IMAG(EFFSLM(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
!~          IF (LQTFP .EQ. 1) THEN
!~              WRITE(IJKJ,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
!~              WRITE(IJKK,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,ICER)),NW1=1,NHASKIND)
!~          ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!
        WRITE(IJK,1989) RCER(NRCER),(TABW(NW1),NW1=1,N)
        WRITE(IJKI,1989) RCER(NRCER),(TABW(NW1),NW1=1,N)
        IF (LQTFP .EQ. 1) THEN
            WRITE(IJKJ,1989) RCER(NRCER),(TABW(NW1),NW1=1,N)
            WRITE(IJKK,1989) RCER(NRCER),(TABW(NW1),NW1=1,N)
        ENDIF
        DO 400 NW2=1,N
            WRITE(IJK,1991)  TABW(NW2),(REAL(EFFSLM(IJ,NW1,NW2,NRCER)),NW1=1,N)
            WRITE(IJKI,1991) TABW(NW2),(IMAG(EFFSLM(IJ,NW1,NW2,NRCER)),NW1=1,N) 
            IF (LQTFP .EQ. 1) THEN
                ! WRITE(IJKJ,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,NRCER)),NW1=1,N) BUG FIX: INNOSEA
                WRITE(IJKJ,1991) TABW(NW2),(REAL(EFFSLP(IJ,NW1,NW2,NRCER)),NW1=1,N)
                WRITE(IJKK,1991) TABW(NW2),(IMAG(EFFSLP(IJ,NW1,NW2,NRCER)),NW1=1,N) 
            ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        400 CONTINUE

        WRITE(STRFMT,*) "# FORMAT:",CHAR(10),				&
     & "# Rext[1]  W2[1]    --- W2[j]    --- W2[N]",CHAR(10),		&
     & "# W1[1]    QTF[1,1] --- QTF[1,j] --- QTF[1,N]",CHAR(10),	&
     & "# .         .            .            .",CHAR(10),		&
     & "# .         .            .            .",CHAR(10),		&
     & "# .         .            .            .",CHAR(10),		&
     & "# W1[i]    QTF[i,1] --- QTF[i,j] --- QTF[i,N]",CHAR(10),	&
     & "# .         .            .            .",CHAR(10),		&
     & "# .         .            .            .",CHAR(10),		&
     & "# .         .            .            .",CHAR(10),		&
     & "# W1[N]    QTF[N,1] --- QTF[N,j] --- QTF[N,N]",CHAR(10),	&
     & "# Rext[2]   --- ",CHAR(10),					&
     & "#  . ",CHAR(10),						&
     & "#  . ",CHAR(10),						&
     & "#  . ",CHAR(10),CHAR(10)
        WRITE(IJK,*) STRFMT
        WRITE(IJKI,*) STRFMT
        CLOSE(IJK)
        CLOSE(IJKI)
	IF (LQTFP .EQ. 1) THEN
		WRITE(IJKJ,*) STRFMT
		WRITE(IJKK,*) STRFMT
!!!! version matrice antitriangulaire sup pour les QTF+ (0 ailleurs) !!!!
		WRITE(IJKJ,*) CHAR(10),CHAR(10),"# NB: Les valeurs des QTF+ pour w1+w2>n*dw sont definies a zeros.",CHAR(10),&
		& "# en effet, un calcul de ces valeurs necessiterait un calcul d'ordre 1 sur 2 fois plus de pulsation."
		WRITE(IJKK,*) CHAR(10),CHAR(10),"# NB: Les valeurs des QTF+ pour w1+w2>n*dw sont definies a zeros.",CHAR(10),&
		& "# en effet, un calcul de ces valeurs necessiterait un calcul d'ordre 1 sur 2 fois plus de pulsation."
	    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		CLOSE(IJKJ)
		CLOSE(IJKK)
	ENDIF
410 CONTINUE

    STOP
    END PROGRAM

    FUNCTION F3(K,W,H)
	USE PARA
        IMPLICIT NONE
        REAL F3,K,W,H
    !    PRINT *,'H',H
    !    PRINT *,(H<=0 .OR. H>=10.**20)
        IF(H>=0 .AND. H<=10.**20 .AND. K*H<30)THEN
            F3=K**2/(W*COSH(K*H)**2)
    !        PRINT *,F3
        ELSE
            F3=0.!K**2/W
        ENDIF
    !    PRINT *,F3
    ! JND : message d'erreur inutile 
!~ 	IF(F3==0) THEN 
!~ 		PRINT *, 'WARNING :  F3 (DZZ) NUL // W=',W,'K=',K,'ch(kh)=',COSH(K*H)
!~ 	ENDIF

        RETURN
        END
    FUNCTION APBES(KBES,XAP)
        !!!!                                                                                !!!!!!!!!
        !!! FONCTION APPROXIMATION DES FONCTIONS DE BESSEL, NECESSITE LES TABLES (COMMON BESSEL) !!!!
        !!!                                                                                 !!!!!!!!!
	USE PARA
        IMPLICIT NONE
        INTEGER IZ
        COMMON BESSEL,XPLOT
        REAL,DIMENSION(0:NN,NPASZ) ::BESSEL
        REAL,DIMENSION(NPASZ) ::XPLOT
        REAL APBES,XAP,MULT
        INTEGER KBES
        IZ=2
        MULT=1.
        IF (KBES<0) THEN
                KBES=-KBES
                MULT=(-1)**KBES
        ENDIF
        DO WHILE(XPLOT(IZ)<=XAP)
    !        PRINT *,IZ,X(IZ),XAP
            IZ=IZ+1
        ENDDO
        APBES=MULT*(BESSEL(KBES,IZ)-BESSEL(KBES,IZ-1))/(XPLOT(IZ)-XPLOT(IZ-1))*(XAP-XPLOT(IZ-1))+BESSEL(KBES,IZ-1)
    !    PRINT *,BESSEL(N,IZ-1),APBES,BESSEL(N,IZ)
            IF (APBES==0) PRINT *, 'ERREUR APBESS NUL'

        RETURN
    END

    FUNCTION EPS(KBES)
        IMPLICIT NONE
        INTEGER KBES
        REAL EPS
        IF (KBES==0)THEN
            EPS=1.
        ELSE
            EPS=2.
        ENDIF
        IF(EPS/=1 .AND. EPS/=2)PRINT *,'ERREUR EPS NUL'
        RETURN

    END
    FUNCTION F1(Z,K,H)
        IMPLICIT NONE
        REAL F1
        REAL Z,H
        REAL K
	! convention axe z ascendant (--> z<0 dans l'eau)
	IF (Z==0.) THEN
	    F1=1.
	ELSEIF(H >= 1.E20 .OR. H<=0 .OR. (K*(Z+H)>50.)) THEN
            F1=EXP(K*Z)
        ELSE
            F1=COSH(K*(Z+H))/COSH(K*H)
        ENDIF
	! JND : message d'erreur inutile 
!~         IF(F1==0)PRINT *,'ERREUR F1 NUL',F1
        RETURN

    END

    FUNCTION F2(Z,K,H)
        IMPLICIT NONE
        REAL F2
        REAL Z,H
        REAL K
	! convention axe z ascendant (--> z<0 dans l'eau)
    !    PRINT *,K
        IF(H >= 1.E20 .OR. H<=0 .OR. (K*(Z+H)>50.))THEN
            F2=EXP(K*Z)
        ELSE
            F2=COSH(K*(Z+H))/( ( K*H*(1-TANH(K*H)**2) + TANH(K*H) ) * COSH(K*H) )
        ENDIF	
	! JND : message d'erreur inutile 
!~         IF(F2==0)PRINT *,'ERREUR F2 NUL',F2
        RETURN
    END



    FUNCTION IL(NOM)
                IMPLICIT NONE
                INTEGER IL
                CHARACTER(10) :: NOM
                IL=INDEX(NOM,' ')-1
                IF(IL < 0)IL=LEN(NOM)
                IF(IL == 0)THEN
                    NOM='DEFAUT'
                    IL=6
                ENDIF
        RETURN
    END

    FUNCTION CL(KBES,ZSB,ZSS,AK0)
        USE PARA
	IMPLICIT NONE
        REAL XM(2*NFA),YM(2*NFA),ZM(2*NFA),AIRE(NFA)
        COMMON/MAIL/ XM,YM,ZM,AIRE
        COMPLEX ZSB(NFA),ZSS(NFA)
        COMPLEX CL
        COMMON BESSEL,XPLOT
        REAL,DIMENSION(0:NN,NPASZ) ::BESSEL
        REAL,DIMENSION(NPASZ) ::XPLOT
        REAL AK0,ALPHA,RAY,AIT
        INTEGER IFAC
        REAL XEFF,YEFF,ZEFF,GM,H,PI4,DPI,QPI
        INTEGER NSYMY,NJJ,NP,IMX,IXX,NEXP,NC,NCO
        COMMON/CST/NC,NCO,NSYMY,NJJ,NP,IMX,IXX,XEFF,YEFF,ZEFF,GM,&
      &  H,PI4,DPI,QPI,NEXP
        INTEGER KBES
        REAL APBES,EPS,F1
            CL=CMPLX(0.,0.)
    !        PRINT *,(SQRT(XM(IFAC)**2+YM(IFAC)**2),IFAC=1,IMX)
    !        PRINT *,IMX
            AIT=0.
    !        PRINT *,SQRT(AK0*G*TANH(AK0*H))
            DO 20 IFAC=1,IMX
                ALPHA=ATAN2(YM(IFAC),XM(IFAC))
    !            PRINT *,ALPHA
                AIT=AIT+AIRE(IFAC)!AIRE TOTALE POUR VERIFICATION
                RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                CL=CL+ZSB(IFAC)*F1(ZM(IFAC),AK0,H)*EPS(KBES)*(-ZI)**KBES*APBES(KBES,AK0*RAY)*AIRE(IFAC)&
                &*COS(ALPHA*KBES)
    20 CONTINUE
    !        PRINT *,AIT
    !        PRINT *,NSYMY
            IF(NSYMY==1) THEN
    !            PRINT *,'CL NSYM'
                DO 21 IFAC=1,IMX
                    ALPHA=ATAN2(-YM(IFAC),XM(IFAC))
                    RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                    CL=CL+ZSS(IFAC)*F1(ZM(IFAC),AK0,H)*EPS(KBES)*(-ZI)**KBES*APBES(KBES,AK0*RAY)*AIRE(IFAC)&
                    &*COS(ALPHA*KBES)
                21 CONTINUE
            ENDIF
            CL=-CL/(4*PI)
        RETURN
        END

    FUNCTION SL(KBES,ZSB,ZSS,AK0)
        USE PARA
	IMPLICIT NONE
        INTEGER KBES
        REAL XM(2*NFA),YM(2*NFA),ZM(2*NFA),AIRE(NFA)
        COMMON/MAIL/ XM,YM,ZM,AIRE
        COMPLEX ZSB(NFA),ZSS(NFA)
        COMPLEX SL
        COMMON BESSEL,XPLOT
        REAL,DIMENSION(0:NN,NPASZ) ::BESSEL
        REAL,DIMENSION(NPASZ) ::XPLOT
        REAL AK0,ALPHA
        REAL XEFF,YEFF,ZEFF,GM,H,PI4,DPI,QPI
        INTEGER NSYMY,NJJ,NP,IMX,IXX,NEXP,NC,NCO
        COMMON/CST/NC,NCO,NSYMY,NJJ,NP,IMX,IXX,XEFF,YEFF,ZEFF,GM,&
      &  H,PI4,DPI,QPI,NEXP
        INTEGER IFAC
        REAL RAY
        REAL APBES
        REAL EPS,F1
            SL=CMPLX(0.,0.)


            DO 20 IFAC=1,IMX
                ALPHA=ATAN2(YM(IFAC),XM(IFAC))
                RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                SL=SL+ZSB(IFAC)*F1(ZM(IFAC),AK0,H)*EPS(KBES)*(-ZI)**KBES*APBES(KBES,AK0*RAY)*AIRE(IFAC)&
                    &*SIN(ALPHA*KBES)
    20 CONTINUE
            IF(NSYMY==1) THEN
                DO 21 IFAC=1,IMX
                    ALPHA=ATAN2(-YM(IFAC),XM(IFAC))
                    RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                    SL=SL+ZSS(IFAC)*F1(ZM(IFAC),AK0,H)*EPS(KBES)*(-ZI)**KBES*APBES(KBES,AK0*RAY)*AIRE(IFAC)&
                    &*SIN(ALPHA*KBES)
                21 CONTINUE
            ENDIF
            SL=-SL/(4*PI)
        RETURN
        END

    FUNCTION KOCH(ZSB,ZSS,AK0,THETA)
        USE PARA
	IMPLICIT NONE
!        INTEGER KBES
        REAL XM(2*NFA),YM(2*NFA),ZM(2*NFA),AIRE(NFA)
        COMMON/MAIL/ XM,YM,ZM,AIRE
        COMPLEX ZSB(NFA),ZSS(NFA)
        COMMON BESSEL,XPLOT
        REAL,DIMENSION(0:NN,NPASZ) ::BESSEL
        REAL,DIMENSION(NPASZ) ::XPLOT
        REAL AK0!,ALPHA
        REAL XEFF,YEFF,ZEFF,GM,H,PI4,DPI,QPI
        INTEGER NSYMY,NJJ,NP,IMX,IXX,NEXP,NC,NCO
        COMMON/CST/NC,NCO,NSYMY,NJJ,NP,IMX,IXX,XEFF,YEFF,ZEFF,GM,&
      &  H,PI4,DPI,QPI,NEXP
        INTEGER IFAC
        REAL RAY
!        REAL APBES
        REAL F1,THETA!EPS,
        COMPLEX KOCH
            KOCH=CMPLX(0.,0.)


            DO 20 IFAC=1,IMX
                RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                KOCH=KOCH+ZSB(IFAC)*F1(ZM(IFAC),AK0,H)*EXP(-ZI*AK0*(XM(IFAC)*COS(THETA)+YM(IFAC)&
                &*SIN(THETA)))*AIRE(IFAC)
              !  PRINT *,RAY,KOCH,ZSB(IFAC),F1(ZM(IFAC),AK0,H),ZI,AK0,XM(IFAC),THETA,YM(IFAC),AIRE(IFAC),ZM(IFAC)
    20 CONTINUE
            IF(NSYMY==1) THEN
                DO 21 IFAC=1,IMX
                    RAY=SQRT(XM(IFAC)**2+YM(IFAC)**2)
                    KOCH=KOCH+ZSS(IFAC)*F1(ZM(IFAC),AK0,H)*EXP(-ZI*AK0*(XM(IFAC)*COS(THETA)-YM(IFAC)&
                    &*SIN(THETA)))*AIRE(IFAC)
                21 CONTINUE
            ENDIF
            KOCH=-KOCH/(4*PI)
        RETURN
        END




    FUNCTION INTBESS(IJ,NPRINTW1,N,CSL,SSL,NN,THETA)
        !!!FONCTION QUI DONNE LA VALEUR EN DE LA FONCTION DE THETA POUR   !!!
        !!!        -IJ= 1:PERTURBE, 2->7 RADIES                           !!!
        !!!        -NPRINTW1,PULSATION / N:NB PULS(POUR DIMENSION)         !!!
        !!!        -CSL/SSL TABLEAUX GRACE AUX FONCTIONS DE BESSELS       !!!
        !!!        -NN:NB FCT BESSEL POUR SERIE INFINIE                   !!!
        !!!        -THETA: ANGLE DANS LE CADRAN XOY OU L'ON CALCULE LA FCT!!!
        IMPLICIT NONE
        INTEGER NPRINTW1,IJ,NN,N
        COMPLEX INTBESS
        COMPLEX,DIMENSION(7,0:NN,N) ::CSL,SSL
        INTEGER KBES
        REAL THETA
        INTBESS=CMPLX(0.,0.)
!        PRINT *,IJ
        DO 210 KBES=0,NN
            INTBESS=INTBESS+(CSL(IJ,KBES,NPRINTW1)*COS(THETA*KBES)+SSL(IJ,KBES,NPRINTW1)*SIN(THETA*KBES))
!!            PRINT *,CSL(1,KBES,NPRINTW1),COS(THETA*KBES),(SSL(1,KBES,NPRINTW1)*SIN(THETA*KBES))/SQRT(RAY)
210     CONTINUE
        RETURN
        END


        FUNCTION INTBESSI(PSMN,THETA,BETA)
        !!!FONCTION QUI DONNE LA VALEUR EN DE LA FONCTION DE THETA POUR   !!!
        !!!        -IJ= 1:PERTURBE, 2->7 RADIES                           !!!
        !!!        -NPRINTW1,PULSATION / N:NB PULS(POUR DIMENSION)         !!!
        !!!        -CSL/SSL TABLEAUX GRACE AUX FONCTIONS DE BESSELS       !!!
        !!!        -NN:NB FCT BESSEL POUR SERIE INFINIE                   !!!
        !!!        -THETA: ANGLE DANS LE CADRAN XOY OU L'ON CALCULE LA FCT!!!
	USE PARA
        IMPLICIT NONE
        COMPLEX INTBESSI,INTBESSP
        INTEGER KBES,POURC
        REAL THETA,PSMN,ALPHA,BETA,EPS
!        PRINT *,IJ
        INTBESSI=CMPLX(0.,0.)
        INTBESSP=CMPLX(1.,0.)
        POURC=0
        KBES=0
        OPEN(60,FILE='CONVERGENCE.dat',POSITION='APPEND')
        DO 210 WHILE (ABS(INTBESSP-INTBESSI)>=10**(-10))

            PRINT *,KBES,INTBESSI
            ALPHA=(2*KBES+1.)/4.*PI
            IF (PSMN>0)THEN
                INTBESSP=INTBESSI
                INTBESSI=INTBESSI+EPS(KBES)*(ZI)**KBES*(COS(BETA*KBES)*COS(KBES*THETA)+SIN(BETA*KBES)*SIN(KBES*THETA))&
                &*EXP(ZI*ALPHA)!!!!NE CONVERGE PASSSSSSSS
                WRITE(60,*)KBES,REAL(INTBESSI),AIMAG(INTBESSI)
            ELSE
                INTBESSP=INTBESSI
                INTBESSI=INTBESSI+EPS(KBES)*(ZI)**KBES*(COS(BETA*KBES)*COS(KBES*THETA)+SIN(BETA*KBES)*SIN(KBES*THETA))&
                &*EXP(-ZI*ALPHA)
            ENDIF
!                PRINT *,INTBESSI
!!            PRINT *,CSL(1,KBES,NPRINTW1),COS(THETA*KBES),(SSL(1,KBES,N!RINTW)*SIN(THETA*KBES))/SQRT(RAY)
            KBES=KBES+1
210     CONTINUE
!        PRINT *,'FIN',INTBESSI

        RETURN
        END




    FUNCTION CONST(AM0,H)
	USE PARA
        IMPLICIT NONE
        REAL AM0,H,F2
        COMPLEX CONST
        !CALCUL LA FONCTION SUR DE R QUI DONNE L'AMPLITUDE COMPLEXE APPROXIME!
        CONST=SQRT(8.*PI*AM0)*EXP(ZI*PI/4.)*F2(0.,AM0,H)!/SQRT(LONG)
        IF(AM0==0)PRINT *,'FALSE AM0=0'
        RETURN
        END

    FUNCTION CONSTR(AM0,H)
	USE PARA
        IMPLICIT NONE
        REAL AM0,H,F2
        COMPLEX CONSTR!,F1
        !CALCUL LA FONCTION SUR DE R QUI DONNE L'AMPLITUDE COMPLEXE APPROXIME!
!        PRINT *,(SQRT(AM0*G*TANH(AM0*H)))
        CONSTR=SQRT(8.*PI*AM0)*EXP(ZI*PI/4.)*F2(0.,AM0,H)!*(SQRT(AM0*G*TANH(AM0*H)))!/SQRT(LONG)
        IF(AM0==0)PRINT *,'FALSE AM0=0'
        RETURN
        END

    FUNCTION X0(AK)
      IMPLICIT NONE
      REAL X0,XI,XM,XS,F
      REAL AK
      REAL T,APS,PAS
      INTEGER IITER,ITOUR
      F(T)=AK-T*TANH(T)
      APS=5.E-6
      ITOUR=0
      XI=0.
      XS=XI
      PAS=AMAX1(AK,SQRT(AK))
   30 XS=XS+PAS
      ITOUR=ITOUR+1
      IF(ITOUR.LE.1000)THEN
      IF(F(XS)*F(XI).GT.0)GOTO 30
      ENDIF
      IITER=0
   10 CONTINUE
      XM=(XI+XS)*0.5
      IITER=IITER+1
      IF(IITER.GT.1000.OR.ITOUR.GT.1000)THEN
      WRITE(*,110)ITOUR,IITER
  110 FORMAT(2X,'ERREUR DANS LA RECHERCHE DE LA RACINE',&
     &/2X,'APPROXIMATION =',I5,'   DICHOTOMIE = ',I5)
      STOP
      ELSE
      IF(ABS((XS-XI)/XM).GT.APS)THEN
      IF(F(XM)*F(XI).LT.0)THEN
      XS=XM
      ELSE
      XI=XM
      ENDIF
      GOTO 10
      ELSE
      X0=XM
      ENDIF
      ENDIF
      RETURN
      END



      FUNCTION CIH(AK,Z,H)
!  PROGRAMMES AQUADYN : (15-04-85) P.GUEVEL,J-C.DAUBISSE,G.DELHOMMEAU  C
      IMPLICIT NONE
      REAL CIH,AK,Z,H
      IF(AK*H.LE.20)THEN
      CIH=COSH(AK*(Z+H))/COSH(AK*H)
      ELSE
      CIH=EXP(AK*Z)
      ENDIF
      RETURN
      END


      FUNCTION LAMPS(M,N,P)
	USE PARA
        IMPLICIT NONE
        INTEGER M,N,P
        REAL KRO,LAMPS,EPS
        LAMPS=PI/EPS(P)*(KRO(ABS(P),ABS(N-M))+KRO(ABS(P),ABS(N+M)))
        IF (LAMPS>=6.29)PRINT *,'ERREUR LAMPS',M,N,P,LAMPS
        RETURN
      END

      FUNCTION LAMMN(M,N,P)
        USE PARA
	IMPLICIT NONE
        INTEGER M,N,P
        REAL KRO,LAMMN,EPS
        LAMMN=PI/EPS(P)*(KRO(ABS(P),ABS(N-M))-KRO(ABS(P),ABS(N+M)))
        IF (LAMMN>=3.15)PRINT *,'ERREUR LAMMN'
        RETURN
      END

      FUNCTION KRO(A,B)
	IMPLICIT NONE
        INTEGER A,B
        REAL KRO
        IF (A==B) KRO=1.
        IF (A/=B) KRO=0.
        RETURN
        IF (KRO/=0. .AND. KRO/=1.)PRINT *,'ERREUR KRO NUL'
      END

      FUNCTION GAMMAN(N,B,A)
	USE PARA
        IMPLICIT NONE
        REAL B,A
        INTEGER N
        COMPLEX GAMMAN
        IF (0.<=B .AND. B<A) THEN
!            PRINT *,'YEAAS'
!            PRINT *,'ILY A B=',B,'ET A=',A,'ET N=',N
            GAMMAN=EXP(ZI*N*ASIN(B/A))/(A**2-B**2)**(1./2.)
!            PRINT *,'ET GAMMA VAUT',GAMMAN
        ELSEIF (0.<A .AND. A<B) THEN
!            PRINT *,'JE DOIS Y ETRE ICI'
            GAMMAN=ZI*EXP(1./2.*N*PI*ZI)/(B**2-A**2)**(1/2.)*(A/(B+(B**2-A**2)**(1./2.)))**N
        ELSE
            PRINT *, 'ERROR,N,B,A=',N,B,A
        ENDIF
        RETURN
      END

      FUNCTION LAMBDAN(N,B,A)
        IMPLICIT NONE
        REAL B,A!,PI
        INTEGER N
        COMPLEX LAMBDAN,GAMMAN
        IF (B<0) THEN
            LAMBDAN=CONJG(GAMMAN(N,-B,A))
!            PRINT *,'YEAAS2'
        ENDIF
        IF (B>=0)THEN
            LAMBDAN=(GAMMAN(N,B,A))
!        PRINT *,"COUCOU JE SUIS LA ET C'EST NORMAL"
!            PRINT *,'ET LAMBDA VAUT=',LAMBDAN
        ENDIF
        RETURN
      END




      FUNCTION MK(K,Z,H)
	USE PARA
        IMPLICIT NONE
        REAL K,Z,H,F2
        COMPLEX MK
        MK=SQRT(8.*PI*K)*F2(Z,K,H)
        IF (MK==0.) PRINT *, 'ERREUR M=0','K=',K
        RETURN
      END

      FUNCTION KAPPA(W1,W2,K1,K2,H)
	USE PARA
        IMPLICIT NONE
        REAL W1,W2,K1,K2,H
        COMPLEX KAPPA,DR1,DR2
        REAL DZ,F3
        DR1=ZI*K1
        DR2=ZI*K2
        KAPPA=  ZI*(W1-W2)*(DR1*CONJG(DR2)+DZ(K1,H)*DZ(K2,H))&
              &+ZI*W1*W2/2.*(F3(K1,W1,H)-F3(K2,W2,H))
        IF (ABS(KAPPA)==0.)PRINT *,'ATTENTION KAPPA =0, W1=',W1,'W2=',W2
        RETURN
      END

      FUNCTION XI(W1,W2,K1,K2,K3,H)
        USE PARA
	IMPLICIT NONE
        REAL W1,W2,K1,K2,H,K3
        COMPLEX XI,KAPPA,MK
        XI=-G/W1*KAPPA(W1,W2,K1,K2,H)*MK(K3,0.,H)*MK(K2,0.,H)
        IF (ABS(XI)==0.) PRINT *,'ATTENTION F ASSYMP =0, W1=',W1,'W2=',W2
        RETURN
      END

      FUNCTION XIPR(W1,W2,K1,K2,K3,H)
	USE PARA
        IMPLICIT NONE
        REAL W1,W2,K1,K2,H,K3
        COMPLEX XIPR,KAPPA,MK
	XIPR=-G/W2*KAPPA(W1,W2,K1,K2,H)*MK(K3,0.,H)*MK(K2,0.,H)
        IF (ABS(XIPR)==0.) PRINT *,'ATTENTION F ASSYMP =0, W1=',W1,'W2=',W2
        RETURN
      END


      FUNCTION DZ(K,H)
        IMPLICIT NONE
        REAL DZ,H,K
        IF (H==0 .OR. H>=10.**20)THEN
            DZ=K
        ELSE
            DZ=K*TANH(K*H)
        ENDIF
            IF (DZ==0) PRINT *,'ERREUR, DZ=0; K=',K
        RETURN
      END

    FUNCTION PDSOMME(J,IJ,CSL,SSL,NN,N,BETA,N2,N3,THETA)
        IMPLICIT NONE
        COMPLEX PDSOMME,ULK
        REAL BETA,LAMMN,LAMPS,THETA
        INTEGER J,NN,N,L,K,IJ,N2,N3
        COMPLEX,DIMENSION(7,0:NN,N) ::CSL,SSL
        LOGICAL FIN
        PDSOMME=CMPLX(0.,0.)
        FIN=.FALSE.
        DO 1 L=0,NN
            DO 2 K=0,NN
                ULK=( CONJG(CSL(1,K,N2))*CSL(2,L,N3)*COS(K*THETA)*COS(L*THETA)&
                &    +CONJG(SSL(1,K,N2))*SSL(2,L,N3)*SIN(K*THETA)*SIN(L*THETA)&
                &    +CONJG(CSL(1,K,N2))*SSL(2,L,N3)*COS(K*THETA)*SIN(L*THETA)&
                &    +CONJG(SSL(1,K,N2))*CSL(2,L,N3)*SIN(K*THETA)*COS(L*THETA))
                PDSOMME=PDSOMME+ULK
!                IF (LAMMN(J,K,L)/=0)PRINT *,'LAMBDAPS NON NUL:',J,K,L,LAMMN(J,K,L)
!                IF (L==K-J .OR. L==K+J .OR. L==J-K ) PRINT *, 'ON DOIT ETRE NON NUL',J,K,L

            2 CONTINUE
        1 CONTINUE
        IF(PDSOMME==0)PRINT *,"ERREUR KJ' NUL"
        RETURN
      END
      FUNCTION PDSOMMEB(J,IJ,CSL,SSL,NN,N,BETA,N2,N3,THETA)
        IMPLICIT NONE
        COMPLEX PDSOMMEB,ULK
        REAL BETA,LAMMN,LAMPS,THETA
        INTEGER J,NN,N,L,K,IJ,N2,N3
        COMPLEX,DIMENSION(7,0:NN,N) ::CSL,SSL
        LOGICAL FIN
        PDSOMMEB=CMPLX(0.,0.)
        FIN=.FALSE.
        DO 1 L=0,NN
            DO 2 K=0,NN
                ULK=( (CSL(1,K,N2))*CSL(2,L,N3)*COS(K*THETA)*COS(L*THETA)&
                &    +(SSL(1,K,N2))*SSL(2,L,N3)*SIN(K*THETA)*SIN(L*THETA)&
                &    +(CSL(1,K,N2))*SSL(2,L,N3)*COS(K*THETA)*SIN(L*THETA)&
                &    +(SSL(1,K,N2))*CSL(2,L,N3)*SIN(K*THETA)*COS(L*THETA))
                PDSOMMEB=PDSOMMEB+ULK
!                IF (LAMMN(J,K,L)/=0)PRINT *,'LAMBDAPS NON NUL:',J,K,L,LAMMN(J,K,L)
!                IF (L==K-J .OR. L==K+J .OR. L==J-K ) PRINT *, 'ON DOIT ETRE NON NUL',J,K,L

            2 CONTINUE
        1 CONTINUE
        IF(PDSOMMEB==0)PRINT *,"ERREUR KJ' NUL"
        RETURN
      END


      FUNCTION KJ(J,IJ,CSL,SSL,NN,N,BETA,N2,N3)
        IMPLICIT NONE
        COMPLEX KJ,ULK
        REAL BETA,LAMMN,LAMPS
        INTEGER J,NN,N,L,K,IJ,N2,N3!,IND
        COMPLEX,DIMENSION(7,0:NN,N) ::CSL,SSL
        LOGICAL FIN
        KJ=CMPLX(0.,0.)
        FIN=.FALSE.!!A OPTIMISER CAR LES COEFFS TENDENT TRES VITE VERS 0, DONC PAS FORCEMENT BESOIN DE CALCULER UN 10^-12 QUI APPARAIT. (PAREIL POUR KJPR)

        DO 1 L=0,NN
            DO 2 K=0,NN
                ULK=( CONJG(CSL(1,K,N2))*CSL(IJ+1,L,N3)*LAMPS(J,K,L)&
                &    +CONJG(SSL(1,K,N2))*SSL(IJ+1,L,N3)*LAMMN(K,L,J))*COS(REAL(J)*BETA)&
                &  +( CONJG(CSL(1,K,N2))*SSL(IJ+1,L,N3)*LAMMN(L,J,K)&
                &    +CONJG(SSL(1,K,N2))*CSL(IJ+1,L,N3)*LAMMN(J,K,L))*SIN(REAL(J)*BETA)
                KJ=KJ+ULK
!                IF(REAL(ULK)/REAL(KJ)<=10**(-6) .AND. IMAG(ULK)/IMAG(KJ)<=10**(-6))EXIT
!                IF (LAMMN(J,K,L)/=0)PRINT *,'LAMBDAPS NON NUL:',J,K,L,LAMMN(J,K,L)
!                IF (L==K-J .OR. L==K+J .OR. L==J-K ) PRINT *, 'ON DOIT ETRE NON NUL',J,K,L

            2 CONTINUE
        1 CONTINUE
        IF(KJ==0)PRINT *,'ERREUR KJ NUL'
        RETURN
      END
      FUNCTION KJPR(J,IJ,CSL,SSL,NN,N,BETA,N2,N3)
        IMPLICIT NONE
        COMPLEX KJPR,ULK
        REAL BETA,LAMMN,LAMPS
        INTEGER J,NN,N,L,K,IJ,N2,N3!,IND
        COMPLEX,DIMENSION(7,0:NN,N) ::CSL,SSL
        LOGICAL FIN
        KJPR=CMPLX(0.,0.)
        FIN=.FALSE.
        DO 1 L=0,NN
            DO 2 K=0,NN
                ULK=( (CSL(1,K,N2))*CSL(IJ+1,L,N3)*LAMPS(J,K,L)&
                &    +(SSL(1,K,N2))*SSL(IJ+1,L,N3)*LAMMN(K,L,J))*COS(REAL(J)*BETA)&
                &  +( (CSL(1,K,N2))*SSL(IJ+1,L,N3)*LAMMN(L,J,K)&
                &    +(SSL(1,K,N2))*CSL(IJ+1,L,N3)*LAMMN(J,K,L))*SIN(REAL(J)*BETA)
                KJPR=KJPR+ULK
!                IF (LAMMN(J,K,L)/=0)PRINT *,'LAMBDAPS NON NUL:',J,K,L,LAMMN(J,K,L)
!                IF (L==K-J .OR. L==K+J .OR. L==J-K ) PRINT *, 'ON DOIT ETRE NON NUL',J,K,L
            2 CONTINUE
        1 CONTINUE
        IF(KJPR==0)PRINT *,'ERREUR KJ NUL'
        RETURN
      END
